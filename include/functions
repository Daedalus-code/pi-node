#!/bin/bash

# By Rainman
# V20212312
# 0.9.7.4

# shellcheck disable=SC2034  # Unused variables left for readability

# script version for dashbord
VERSION="v0.9.7.4"

source /home/pi/pitrump.conf
source /usr/local/bin/include/color

# time - date, trim extra spaces with xargs
CLOCK=$(date "+%H:%M:%S" 2>&1)
# date for logs
LOG_DATE=$(date '+%Y-%d-%mT%TZ' 2>&1)

# wait on node (daemon) to start
until pidof trumpcoind 2>&1 | wc -w 2>&1 | egrep "1" &>/dev/null; do
  RANDOM_PID=$((((RANDOM % 999) + 1)))
  clear
  printf '%b' "Waiting on trumpcoin (${GR:?}${RANDOM_PID:?}${N0:?}) daemon..\n"
  sleep 2
done

### folders, logs and daemon ###################################################

# create data, peers, tmp directory, ruled by configuration
# this is for systems using memory as a directory
# make sure directories exist, /tmp, /var/tm, /var/log, /var/spool/mqueue)
mkdir "${LOG_DIR:?}"/node_data &>/dev/null
mkdir "${LOG_DIR:?}"/node_data/peers &>/dev/null
mkdir "${LOG_DIR:?}"/node_data/tmp &>/dev/null

# wallet daemon uptime function
# function for waiting with stuff before a limit (seconds) is reached
function uptime_daemon() {
  PID="$(pidof trumpcoind 2>&1)"
  HZ=$(getconf CLK_TCK 2>&1)
  UPTIME_CMD=$(awk '{print $1}' </proc/uptime)
  STARTTIME=$(awk '{print $22}' </proc/"$PID"/stat)
  echo $(("${UPTIME_CMD%.*}" - "$STARTTIME" / "$HZ"))
}

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "300" ]] &>/dev/null; then
  # tail last line in debug.log
  LAST_LOG=$(tail -n 1 "${WALLET_LOG_DIR:?}"/debug.log 2>&1)
  # get log size from debug.log
  LOG_SIZE=$(ls -lS --block-size=M "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | awk '{ print $5 }' 2>&1)
  # log max :n characters, w log size
  LAST_LOG="${LAST_LOG:0:188} log=$LOG_SIZE"
else # log lines (tail debug)
  LAST_LOG=$(tail -n 1 "${WALLET_LOG_DIR:?}"/debug.log 2>&1)
  # log max :n characters, no log size
  LAST_LOG="${LAST_LOG:0:188}"
fi

### system information, load, user, cpu temp ###################################

# get system load
LOAD=$(uptime 2>&1 | egrep -o "[0-9]+.[0-9]+, [0-9]+.[0-9]+, [0-9]+.[0-9]+" 2>&1 | tr -d ',' 2>&1)
# get system user
USER=$(whoami 2>&1 | awk '{ print $1 }' 2>&1)
# get cpu temp, celcius, fahrenheit, (raspberry pi)
CPU_CTEMP=$(</sys/class/thermal/thermal_zone0/temp)
CPU_CTEMP=$(echo "$CPU_CTEMP / 100 * 0.1" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
CPU_FTEMP=$(echo "(1.8 * $CPU_CTEMP) + 32" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)

### system memory ##############################################################

# get used swap
USED_SWAP=$(swapon -s 2>&1 | grep "/swapfile" 2>&1 | awk '{ print $4 }' 2>&1)
# calculate megabytes (used swap)
USED_SWAP=$(echo "$USED_SWAP/1024" 2>&1 | bc -l 2>&1)
# get total swap
TOTAL_SWAP=$(swapon -s 2>&1 | grep "/swapfile" 2>&1 | awk '{ print $3 }' 2>&1)
# calculate megabytes (total swap)
TOTAL_SWAP=$(echo "$TOTAL_SWAP/1024" 2>&1 | bc -l 2>&1)
# get free Memory
FREE_MEM=$(free --mega 2>&1 | grep "Mem" 2>&1 | awk '{ print $4 }' 2>&1)
# get total Memory
TOTAL_MEM=$(free --mega 2>&1 | grep "Mem" 2>&1 | awk '{ print $2 }' 2>&1)
# calculate total system total memory + total swap
TOTAL_MEM=$(echo "$TOTAL_MEM+$TOTAL_SWAP" 2>&1 | bc -l 2>&1 | awk -F. '{ print $1 }' 2>&1)
# total mem (colors)
TOTAL_MEM="${G1:?}${TOTAL_MEM:?}${N0:?}"
# calculate total free system memory + used swap
FREE_MEM=$(echo "$(echo "$TOTAL_SWAP-$USED_SWAP" 2>&1 | bc -l 2>&1)+$FREE_MEM" 2>&1 | bc -l 2>&1 | awk -F. '{ print $1 }' 2>&1)
# free mem (colors)
FREE_MEM="${G1:?}${FREE_MEM:?}M${N0:?}"

### system space ###############################################################

# get free Space, mmc block device #0, partition #2, partition #2, dev/root
USED_HDD=$(df -h 2>&1 | egrep "mmcblk0p2|mmcblk0p3|/dev/root" 2>&1 | awk '{ print $3 }' 2>&1)
# get used hdd (colors)
USED_HDD="${G1:?}${USED_HDD:?}${N0:?}"
USED_HDD_P=$(df -h 2>&1 | egrep "mmcblk0p2|mmcblk0p3|/dev/root" 2>&1 | awk '{ print $5 }' 2>&1)

### get wan/lan.ip, internet/intranet ##########################################

# if non responsive
IP_ADDRESS="${GR:?}0.0.0.0${N0:?}"
# get interface
IFCONFIG=$(ifconfig 2>&1 | egrep "wlan*|eth*" 2>&1)
# get ip address from interface
IP_ADDRESS=$(echo "$IFCONFIG" 2>&1 | egrep "inet " 2>&1 | grep -vwE "127.0.0.1" 2>&1 | awk '{ print $2 }' 2>&1)
# get ip address (no colors)
IP_ADDRESS_N="$IP_ADDRESS"
# get ip address (colors)
IP_ADDRESS="${C1:?}$IP_ADDRESS${N0:?}"
# interface icon (top right)
INTERFACE=$(echo "$IFCONFIG" 2>&1 | egrep "wlan*|eth*" 2>&1 | awk '{ print $1 }' 2>&1 | awk -F: '{ print $1 }' 2>&1 | head -1 2>&1)

# update repository, ruled by configuration
if [[ "$(date +%H%M 2>&1 | grep -Eo "0000" 2>&1)" ]] &>/dev/null; then
  if [[ "$UPDATE_REPO" -eq "1" ]] &>/dev/null; then
    # update repo, if set
    cd /home/"$(whoami)"/trump-node || exit &&
      git pull -q && bash include/install 2>&1
  fi
fi

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "300" ]] &>/dev/null; then
  # get wan address, if missing
  if [ ! -f "${LOG_DIR:?}"/node_data/getwan ] &>/dev/null; then
    # get my wan ip from myip.opendns.com -> resolver1.opendns.com
    host myip.opendns.com resolver1.opendns.com >"${LOG_DIR:?}"/node_data/getwan 2>&1
    printf '%b' "${LOG_DATE:?} Status() GetWan.Data(): Found Wan Address (${CY:?}$(grep "address" "${LOG_DIR:?}"/node_data/getwan 2>&1 | egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1)${N0:?})${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    # get public ip address
    PUBLIC_IP=$(grep "address" "${LOG_DIR:?}"/node_data/getwan 2>&1 |
      egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1)
    # public ip (colors)
    PUBLIC_IP="${C1:?}${PUBLIC_IP:?}${N0:?}"
  fi
else # output localhost (127.0.0.1) if not found
  # waiting on daemon data (colors)
  PUBLIC_IP="${GR:?}127.0.0.1${N0:?}"
fi

### download and upload ########################################################

# get download from wlan(*) - eth(*)
DOWNLOAD=$(ifconfig 2>&1 | egrep "wla*|eth*" 2>&1 | grep "RX packets" 2>&1 | head -1 2>&1 | awk '{ print $6 $7 }' 2>&1 | tr -d '()' 2>&1)
# get upload from wlan(*) - eth(*)
UPLOAD=$(ifconfig 2>&1 | egrep "wla*|eth*" 2>&1 | grep "TX packets" 2>&1 | head -1 2>&1 | awk '{ print $6 $7 }' 2>&1 | tr -d '()' 2>&1)

### tor ########################################################################

# get tor status
if grep "127.0.0.1:9050" "${LOG_DIR:?}"/node_data/getinfo &>/dev/null; then
  TOR_ICON="${P1:?}P$N0"
  # running proxy (tor), do this once
  if [ ! -f "${LOG_DIR:?}"/node_data/onion ] &>/dev/null; then
    # get onion address from debug.log
    egrep -o "[a0-z9]+.onion" "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | tail -1 >"${LOG_DIR:?}"/node_data/onion 2>&1
    printf '%b' "${LOG_DATE:?} Status() GetOnion.Data: Found Onion Address (${P1:?}$(cat "${LOG_DIR:?}"/node_data/onion 2>/dev/null)${N0?:})${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
  # get onion address
  PUBLIC_IP=$(cat "${LOG_DIR:?}"/node_data/onion 2>/dev/null)
  if [[ -z "$PUBLIC_IP" ]] &>/dev/null; then
    # random onion (cryptography)
    PUBLIC_IP=$(openssl rand -base64 12 2>&1)
  fi # output onion address (short version)
  PUBLIC_IP="${P1:?}${PUBLIC_IP:0:8}...onion${N0:?}"
else # tor icon (top right)
  TOR_ICON="${GR:?}P$N0"
  # tor public ip while waiting on data
  PUBLIC_IP="${GR:?}127.0.0.1$N0"
fi

### adding nodes ###############################################################

# remove empty files, onion
if [ ! -s "${LOG_DIR:?}"/node_data/onion ] &>/dev/null; then
  rm "${LOG_DIR:?}"/node_data/onion &>/dev/null
fi # nodes
if [ ! -s "${LOG_DIR:?}"/node_data/nodes ] &>/dev/null; then
  rm "${LOG_DIR:?}"/node_data/nodes &>/dev/null
fi

# update addnodes, failed peers, along with ticker price (every half, & hour)
if [[ "$(date '+%T' 2>&1 | egrep "[0-9]+:30:[0-9]+|[0-9]+:00:[0-9]+" 2>&1)" ]] &>/dev/null; then

  # get time now
  NOW_TIME=$(date 2>&1 | awk '{ print $4 }' 2>&1 | egrep -o "([0-9]+:[0-9]+)" 2>&1 | tr -d ':' 2>&1)
  # get screen start time
  SCR_TIME=$(screen -list 2>&1 | egrep -o "([0-9]+:[0-9]+)" 2>&1 | tr -d ':' 2>&1)
  # calculate difference
  SCR_CALC=$(echo "$NOW_TIME-$SCR_TIME" 2>&1 | bc -l 2>&1)

  # if screen time greater than n, kill the screen session
  if [[ "$SCR_CALC" -gt "30" ]] &>/dev/null; then
    # killall old/crashed screen session(s)
    killall screen &>/dev/null
    printf '%b' "${LOG_DATE:?} Status() AddNode.Script Killing Old/Crashed script!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi

  # truncate peers.dat
  truncate -s 0 "${WALLET_DIR:?}"/peers.dat &>/dev/null
  # make sure addnodes.value exist
  touch "${LOG_DIR:?}"/node_data/addnodes.value &>/dev/null

  # if addnodes backup is missing
  if [[ ! -f "${WALLET_DIR:?}"/addnodes ]] &>/dev/null; then
    # make sure addnodes.value exist
    touch "${LOG_DIR:?}"/node_data/addnodes.value &>/dev/null
  fi
  # get addnodes backup value
  ADDNODE_BACKUP=$(cat "${WALLET_DIR:?}"/addnodes 2>/dev/null | wc -l 2>&1)
  # get successfully connected peers value (addnodes.value)
  ADDNODE_VALUE=$(cat "${LOG_DIR:?}"/node_data/peers/success 2>/dev/null | wc -l 2>&1)
  # calculate new bakcup difference
  ADDNODE_NEW_DIFF=$(echo "${ADDNODE_BACKUP:?}-${ADDNODE_VALUE:?}" 2>&1 | bc 2>&1)
  # if bigger than original, update
  if [[ "$ADDNODE_VALUE" -gt "$ADDNODE_BACKUP" ]]; then
    # get addnodes backup value
    ADDNODE_BACKUP=$(cat "${WALLET_DIR:?}"/addnodes 2>/dev/null | wc -l 2>&1)
    # copy successfully connected peers over to wallet directory -> addnodes backup
    cp "${LOG_DIR:?}"/node_data/peers/success "${WALLET_DIR:?}"/addnodes 2>&1
    printf '%b' "${LOG_DATE:?} Status() AddNode.Script Creating Addnodes backup list! Total ${G1:?}$ADDNODE_BACKUP${N0:?} (${ADDNODE_NEW_DIFF:?})${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
  printf '%b' "${LOG_DATE:?} Status() AddNode.Script Status() Addnodes backup list! Total ${G1:?}$ADDNODE_BACKUP${N0:?} (${ADDNODE_NEW_DIFF:?})${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

  # remove old file
  rm "${LOG_DIR:?}"/node_data/nodes &>/dev/null
  printf '%b' "${LOG_DATE:?} Status() Update.Nodes() Re/scan network(s)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  # clean up addnodes.personal
  PERSONAL_ADDNODES_C01=$(cat "${LOG_DIR:?}"/node_data/addnodes.personal 2>/dev/null | wc -l 2>&1)
  cat "${LOG_DIR:?}"/node_data/addnodes.personal 2>/dev/null | grep -vf "${LOG_DIR:?}"/node_data/peers/failed | sort -n 2>&1 | awk '!a[$0]++' >/tmp/addnodes.tmp
  mv /tmp/addnodes.tmp "${LOG_DIR:?}"/node_data/addnodes.personal 2>&1
  PERSONAL_ADDNODES_C02=$(cat "${LOG_DIR:?}"/node_data/addnodes.personal 2>/dev/null | wc -l 2>&1)
  # calculate addnodes.personal difference
  PERSONAL_ADDNODES_DIFF=$(echo "${PERSONAL_ADDNODES_C01:?}-${PERSONAL_ADDNODES_C02:?}" 2>&1 | bc 2>&1)
  printf '%b' "${LOG_DATE:?} Status() Update.Nodes() Cleaning personal addnodes! Removed ${GR:?}${PERSONAL_ADDNODES_DIFF:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
fi

# get node list, ticker (api, arp)
if [ ! -f "${LOG_DIR:?}"/node_data/nodes ] &>/dev/null; then

  # greater than n seconds, continue
  if [[ "$(uptime_daemon)" -gt "600" ]] &>/dev/null; then

    # curl, arp data source
    source /usr/local/bin/include/data

    # make sure addnodes.script list, avgconfirmation exist
    touch "${LOG_DIR:?}"/node_data/addnodes.script &>/dev/null

    # count failed connections, feed output to debug.log
    FAIL_COUNT=$(wc -l "${LOG_DIR:?}"/node_data/peers/failed 2>&1 | awk '{ print $1 }' 2>&1)
    ADDNODE_SI=$(wc -l "${LOG_DIR:?}"/node_data/addnodes.script 2>&1 | awk '{ print $1 }' 2>&1)
    ADDNODE_NOD=$(wc -l "${LOG_DIR:?}"/node_data/nodes 2>&1 | awk '{ print $1 }' 2>&1)
    ADDNODE_PSI=$(wc -l "${LOG_DIR:?}"/node_data/addnodes.personal 2>&1 | awk '{ print $1 }' 2>&1)

    # note: heavy reading, do interval reading with date:time
    if [[ "$(date '+%T' 2>&1 | egrep "[0-9]+:[0-9]+5:[0-9]+|[0-9]+:[0-9]+0:[0-9]+" 2>&1)" ]] &>/dev/null; then
      # count all new outbound peer inside debug.log
      grep -c "New outbound peer" "${WALLET_LOG_DIR:?}"/debug.log >"${LOG_DIR:?}"/node_data/success.value 2>&1
      SUCCESS_CO=$(cat "${LOG_DIR:?}"/node_data/success.value 2>/dev/null)
    elif [[ -z "$SUCCESS_CO" ]] &>/dev/null; then
      # non responsive
      SUCCESS_CO="0"
    else # get success value
      SUCCESS_CO=$(cat "${LOG_DIR:?}"/node_data/success.value 2>/dev/null)
    fi

    # success rate calculated
    SUCCESS_RA=$(echo "100/$(echo "$FAIL_COUNT+$SUCCESS_CO" 2>&1 | bc -l 2>&1)*$SUCCESS_CO" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
    # syntax fix
    SUCCESS_RA_SX=$(echo "$SUCCESS_RA" 2>&1 | awk -F. '{ print $1 }' 2>&1)
    # non responsive
    if [[ -z "$SUCCESS_RA_SX" ]] &>/dev/null; then
      SUCCESS_RA_SX="0"
    fi

    # success rate (color rate)
    if [[ "$SUCCESS_RA_SX" -ge "0" ]] &>/dev/null; then
      SRAC="${GR:?}${SUCCESS_RA:?}%"
    fi
    if [[ "$SUCCESS_RA_SX" -ge "10" ]] &>/dev/null; then
      SRAC="${Y0:?}${SUCCESS_RA:?}%"
    fi
    if [[ "$SUCCESS_RA_SX" -ge "25" ]] &>/dev/null; then
      SRAC="${Y1:?}${SUCCESS_RA:?}%"
    fi
    if [[ "$SUCCESS_RA_SX" -ge "50" ]] &>/dev/null; then
      SRAC="${G0:?}${SUCCESS_RA:?}%"
    fi
    if [[ "$SUCCESS_RA_SX" -ge "75" ]] &>/dev/null; then
      SRAC="${G1:?}${SUCCESS_RA:?}%"
    fi

    # onion address (no color)
    ONION_R=$(cat "${LOG_DIR:?}"/node_data/onion 2>/dev/null)
    # wan ip address (no color)
    WANIP_R=$(grep "address" "${LOG_DIR:?}"/node_data/getwan 2>&1 | egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1)

    if [[ -z "$ONION_R" ]] &>/dev/null; then
      # non responsive
      ONION_R="none"
    fi
    if [[ -z "$WANIP_R" ]] &>/dev/null; then
      # non responsive
      WANIP_R="none"
    fi

    # repository latest head
    LATEST_HEAD=$(cd /home/"$(whoami)"/trump-node || exit && git rev-parse --short HEAD 2>&1 | grep -Eo '[a0-z9]{7}' 2>&1 | head -1 2>&1)
    # repository latest date
    LATEST_DATE=$(cd /home/"$(whoami)"/trump-node || exit && git log -1 --format="%at" | xargs -I{} date -d @{} '+%Y/%m/%d')
    # repository latest time
    LATEST_TIME=$(cd /home/"$(whoami)"/trump-node || exit && git log -1 --format="%at" | xargs -I{} date -d @{} '+%H:%M:%S')

    # get unspent count
    UNSPENT_COUNT=$(grep "confirmations" "${LOG_DIR:?}"/node_data/listunspent 2>&1 | wc -l 2>&1)
    # get unspent otal
    UNSPENT_TOTAL=$(grep "confirmations" "${LOG_DIR:?}"/node_data/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ SUM += $1} END { print SUM }' 2>&1)
    # average calculated
    UNSPENT_AVG=$(echo "$UNSPENT_TOTAL/$UNSPENT_COUNT" 2>&1 | bc 2>&1)
    # calculate seconds
    UNSPENT_SEC=$(echo "$UNSPENT_AVG*60" 2>&1 | bc -l 2>&1 | awk -F. '{ print $1 }' 2>&1)
    # calculate seconds into age
    UNSPENT_AGE=$(printf '%dh:%dm' $(("$UNSPENT_SEC/3600")) $(("$UNSPENT_SEC%3600/60")))
    # save calculated value
    echo "${UNSPENT_AGE:?}" >"${LOG_DIR:?}"/node_data/avgconfirmation.value
    UNSPENT_AGE_D=$(echo "$(echo "$UNSPENT_AGE" 2>&1 | egrep -o "[0-9]+h" 2>&1 | tr -d 'h' 2>&1)/24" 2>&1 | bc 2>&1)

    # interval dashbord for debug.log
    # note: should always start later on since daemon start (uptime_daemon)
    printf '%b' "${GR:?}${LOG_DATE:?} Status() - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() SystemTorNet()${N0:?} Onion ${ONION_R:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() SystemInternet${N0:?} WanIP ${WANIP_R:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() SystemIntranet${N0:?} Local ${IP_ADDRESS_N:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() Script.version${N0:?} Repository [${G1:?}${LATEST_HEAD:?}${N0:?}] ${GR:?}${LATEST_DATE:?}${N0:?} ${LATEST_TIME:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() System.Monitor${N0:?} Load ${LOAD:?} - temp ${CPU_CTEMP:?}°C ${CPU_FTEMP:?}°F ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() System.Monitor${N0:?} Free Mem ${FREE_MEM:?}/${TOTAL_MEM:?} - HDDuse ${USED_HDD:?} (${USED_HDD_P:?})${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() Fail/success()${N0:?} Fail ${R1:?}${FAIL_COUNT:?}${N0:?} Success ${G1:?}$SUCCESS_CO${N0:?} Success Rate ${SRAC:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() Addnode.Size()${N0:?} Add New Peers ${CY:?}${ADDNODE_SI:?}${N0:?} Addnode Peers ${C1:?}$ADDNODE_PSI${N0:?} Curl/Arp Nodes ${G1:?}$ADDNODE_NOD${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() Peers.Status()${N0:?} Total ${WALLET_PEERS_TOTAL:?} Latest ${WALLET_PEERS_LATEST:?} Older ${WALLET_PEERS_OTHER:?} - ${G1:?}⇩${N0:?} $DOWNLOAD ${R1:?}⇧${N0:?} $UPLOAD${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() Proof.Of.Work:${N0:?} PoS ${WALLET_STAKES:?} AVG Time (${UNSPENT_AGE_D:?}d) ${GR:?}${UNSPENT_AGE:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  else # waiting on deamon data
    printf '%b' "${LOG_DATE:?} Status() System.Monitor Loading wallet${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

### debug peer(s) tries/connected ##############################################

# note: heavy reading, do interval reading with date:time
if [[ "$(date '+%T' 2>&1 | egrep "[0-9]+:[0-9]+5:[0-9]+|[0-9]+:[0-9]+0:[0-9]+" 2>&1)" ]] &>/dev/null; then

  egrep -o "peer=[0-9]+" "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | egrep -o "[0-9]+" 2>&1 | tail -1 >"${LOG_DIR:?}"/node_data/tries.value 2>&1
fi

### create personal, addnodes.script list(s) ###################################

# create addnodes.script for script below, sort, remove duplicates
# this list (addnodes.script) is used by add_peers script later on
cat "${LOG_DIR:?}"/node_data/nodes 2>/dev/null | sort -n 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/node_data/addnodes.script 2>&1

# create addnodes.extra for personal use, sort, remove duplicates
cat "${LOG_DIR:?}"/node_data/addnodes.personal 2>/dev/null | sort -n 2>&1 | awk '!a[$0]++' 2>&1 | grep -vf /tmp/node_data/peers/success >"${LOG_DIR:?}"/node_data/addnodes.extra 2>&1
# make sure user addnodes exist
touch /home/"$(whoami)"/addnodes &>/dev/null
# get user addnodes
if [[ -s /home/"$(whoami)"/addnodes ]] &>/dev/null; then
  # add extra nodes from user
  egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+.[0-9]+|[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+" /home/"$(whoami)"/addnodes 2>&1 | sort -n 2>&1 | awk '!a[$0]++' >>"${LOG_DIR:?}"/node_data/addnodes.extra 2>&1
  printf '%b' "${LOG_DATE:?} Status() AddNode.Script Adding extra nodes! Total ${G1:?}$(cat /home/"$(whoami)"/addnodes 2>/dev/null | wc -l 2>&1)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
fi
# truncate user addnodes after the fact
truncate -s 0 /home/"$(whoami)"/addnodes &>/dev/null

### create, feed first extra, banned, ipv4, ipv6 address, sort #################

# generate random ip address (ipv4)
RIP_IPV4=$(printf "%d.%d.%d.%d\n" "$((RANDOM % 256))" "$((RANDOM % 256))" "$((RANDOM % 256))" "$((RANDOM % 256))" 2>&1)
# generate random ip address (ipv6)
RIP_IPV6=$(for ((i = 0; i < 8; i++)); do printf "%02x%02x:" $((RANDOM % 256)) $((RANDOM % 256)); done 2>&1 | sed 's/:$//' 2>&1)
# feed address to addnodes.script
echo "$RIP_IPV6" >>"${LOG_DIR:?}"/node_data/addnodes.script 2>&1
echo "$RIP_IPV4" >>"${LOG_DIR:?}"/node_data/addnodes.script 2>&1
# already existing, don't add twice
if ! grep "127.0.0.1" "${LOG_DIR:?}"/node_data/peers/failed &>/dev/null; then
  echo "$IP_ADDRESS_N" >>"${LOG_DIR:?}"/node_data/peers/failed 2>&1
  echo "127.0.0.1" >>"${LOG_DIR:?}"/node_data/peers/failed 2>&1
fi
# feed extra addnodes to addnodes.script
cat "${LOG_DIR:?}"/node_data/addnodes.extra >>"${LOG_DIR:?}"/node_data/addnodes.script 2>/dev/null
# remove duplicates from addnodes.script
cat "${LOG_DIR:?}"/node_data/addnodes.script 2>/dev/null | awk '!a[$0]++' 2>&1 | sort -n >"${LOG_DIR:?}"/node_data/addnodes.tmp 2>&1
# copy addnodes.tmp to addnodes.script
cp "${LOG_DIR:?}"/node_data/addnodes.tmp "${LOG_DIR:?}"/node_data/addnodes.script 2>&1

### failed & success lists #####################################################

# make sure failed, success list(s) exist
touch "${LOG_DIR:?}"/node_data/peers/failed &>/dev/null
touch "${LOG_DIR:?}"/node_data/peers/success &>/dev/null

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "600" ]] &>/dev/null; then

  # note: heavy reading, do interval reading with date:time
  if [[ "$(date '+%T' 2>&1 | egrep "[0-9]+:[0-9]+5:[0-9]+|[0-9]+:[0-9]+0:[0-9]+" 2>&1)" ]] &>/dev/null; then

    # note: reading of debug.log, more heavy with time (more lines)
    # create "failed/refusing" ipv4:ipv6 peers list, sort, remove duplicates
    egrep -o " to [0-9]+.[0-9]+.[0-9]+.[0-9]+.[0-9]+ failed| to [a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+ failed" "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | awk '{ print $2 }' | sort -n | awk '!a[$0]++' >"${LOG_DIR:?}"/node_data/peers/failed 2>&1
    printf '%b' "${LOG_DATE:?} Status() FunctionScript Creating failed peers list! ${G1:?}$(cat "${LOG_DIR:?}"/node_data/peers/failed 2>/dev/null | wc -l 2>&1)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
  # create "stable/working" ipv4/ipv6 peers list, sort, remove duplicates
  # note: only addr, disregard addrlocal
  egrep "addr: [0-9]+.[0-9]+.[0-9]+.[0-9]+.[0-9]+:[0-9]+|addr: [a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.[a0-z9]+.*" "${LOG_DIR:?}"/node_data/getpeerinfo | awk '{ print $2 }' 2>&1 | sort -n 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/node_data/peers/success 2>&1

  ### addnodes.personal list ###################################################

  # count success
  SUCCESS_COUNT=$(cat "${LOG_DIR:?}"/node_data/peers/success 2>/dev/null | wc -l 2>&1)
  # make sure addnodes.personal
  touch "${LOG_DIR:?}"/node_data/addnodes.personal &>/dev/null
  ADDNODE_COUNT=$(cat "${LOG_DIR:?}"/node_data/addnodes.personal 2>/dev/null | wc -l 2>&1)

  # if success count is greater than addnode count
  if [[ "$SUCCESS_COUNT" -gt "$ADDNODE_COUNT" ]] &>/dev/null; then
    # save value, before the fact
    egrep -c "[0-9]+" "${LOG_DIR:?}"/node_data/addnodes.personal >"${LOG_DIR:?}"/node_data/addnodes.value 2>&1
    SUCCESS_VALUE=$(cat "${LOG_DIR:?}"/node_data/addnodes.value 2>/dev/null)
    # create addnodes.personal list if success list, sort, remove duplicates
    cat "${LOG_DIR:?}"/node_data/peers/success 2>/dev/null | sort -n 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/node_data/addnodes.personal 2>&1
    # calculate after the fact
    ADDNODE_COUNT=$(cat "${LOG_DIR:?}"/node_data/addnodes.personal 2>/dev/null | wc -l 2>&1)
    ADDNODE_NEW_DIFF=$(echo "${ADDNODE_COUNT:?}-${SUCCESS_VALUE:?}" 2>&1 | bc 2>&1)
    printf '%b' "${LOG_DATE:?} Status() AddNode.Script Updating Addnodes list! Total ${G1:?}$ADDNODE_COUNT${N0:?} (${ADDNODE_NEW_DIFF:?})${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi

  ### sort & cleanup addnodes.script ###########################################

  # disregard with all list(s) from peers directory
  comm -23 <(sort "${LOG_DIR:?}"/node_data/addnodes.tmp) <(egrep -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' "${LOG_DIR:?}"/node_data/peers/success | sort) >"${LOG_DIR:?}"/node_data/addnodes.script
  comm -23 <(sort "${LOG_DIR:?}"/node_data/addnodes.tmp) <(egrep -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' "${LOG_DIR:?}"/node_data/peers/failed | sort) >"${LOG_DIR:?}"/node_data/addnodes.script

  # make sure node ip is out
  grep -v "$IP_ADDRESS_N" "${LOG_DIR:?}"/node_data/addnodes.script >"${LOG_DIR:?}"/node_data/addnodes.tmp
  cp "${LOG_DIR:?}"/node_data/addnodes.tmp "${LOG_DIR:?}"/node_data/addnodes.script
  # create a raw format to look at, of what went through add_peers script below
  cp "${LOG_DIR:?}"/node_data/addnodes.script "${LOG_DIR:?}"/node_data/addnodes.raw
fi

### addnodes screen script #####################################################

if [[ -f "${LOG_DIR:?}"/node_data/tries.value ]] &>/dev/null; then

  # greater than n seconds, continue
  if [[ "$(uptime_daemon)" -gt "369" ]] &>/dev/null; then

    # look for screen session, if not found, start one
    if ! screen -list 2>&1 |
      grep -q "addnodes" &>/dev/null; then
      # create screen session
      screen -dmS addnodes 2>&1

      # connect nodes found with addnodes list above, (using tmp directory)
      cat >"${LOG_DIR:?}"/add_peers <<'EOF'
#!/bin/bash

# By Rainman
# V20212212
# 0.0.5.2

source /home/pi/pitrump.conf
source /usr/local/bin/include/color

function peers() {
  PEERS_TRIES=$(cat "${LOG_DIR:?}"/node_data/tries.value 2>/dev/null)
  PEERS_ADDNODES=$(cat "${LOG_DIR:?}"/node_data/addnodes.script 2>/dev/null | wc -l 2>&1)
  PEERS_ADDNODES_P=$(cat "${LOG_DIR:?}"/node_data/addnodes.personal 2>/dev/null | wc -l 2>&1)
  PEERS_FAILED=$(cat "${LOG_DIR:?}"/node_data/peers/failed 2>/dev/null | wc -l 2>&1)
  # non responsive
  if [[ -z "$PEERS_TRIES" ]] &>/dev/null; then
    PEERS_TRIES="0"
  fi
}

LOG_DATE=$(date '+%Y-%d-%mT%TZ' 2>&1)
peers
printf '%b' "${LOG_DATE:?} Status() AddNode.Script Starting! Addnodes/New ${PEERS_ADDNODES_P:?}/${PEERS_ADDNODES:?} Failed ${PEERS_FAILED:?} Total Connected ${PEERS_TRIES:?} ${G1:?}>${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

while IFS= read -r ADDS; do
  "$WALLET_DIR"/trumpcoin-cli -datadir=./ -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="$WALLET_DIR"/trumpcoin.conf addnode "$ADDS" onetry 2>&1
done <"${LOG_DIR:?}"/node_data/addnodes.script 2>&1 | shuf # <- connects w shell (add_peers)

LOG_DATE=$(date '+%Y-%d-%mT%TZ' 2>&1)
peers
printf '%b' "${LOG_DATE:?} Status() AddNode.Script Stopping! Addnodes/New ${PEERS_ADDNODES_P:?}/${PEERS_ADDNODES:?} Failed ${PEERS_FAILED:?} Total Connected ${PEERS_TRIES:?} ${GR:?}<${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

# get total.failed value
TF_PEERS=$(cat "${LOG_DIR:?}"/node_data/peers/total.failed 2>/dev/null | awk '!a[$0]++' 2>&1 | wc -l 2>&1)

if echo "$(cat "${LOG_DIR:?}"/node_data/peers/total.failed 2>/dev/null)" 2>&1 | grep "$(cat "${LOG_DIR:?}"/node_data/peers/failed 2>/dev/null)" &>/dev/null; then
  # nothing todo, wait
  printf '%b' "${LOG_DATE:?} Status() AddNode.Script ${G0:?}${TF_PEERS:?}${N0:?} Ban(s) Nothing to ban, waiting.${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
else
  # which one did work, fail the rest (worked = worked (tried to connect) but failed)
  egrep -o "$(cat "${LOG_DIR:?}"/node_data/addnodes.raw 2>/dev/null)" /tmp/debug.log >"${LOG_DIR:?}"/node_data/peers/worked
  comm -23 <(sort "${LOG_DIR:?}"/node_data/addnodes.script) <(egrep -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' "${LOG_DIR:?}"/node_data/peers/worked | sort) >"${LOG_DIR:?}"/node_data/peers/total.failed
  cat "${LOG_DIR:?}"/node_data/peers/total.failed 2>/dev/null | awk '!a[$0]++' >>"${LOG_DIR:?}"/node_data/peers/failed 2>&1
  printf '%b' "${LOG_DATE:?} Status() AddNode.Script ${G0:?}${TF_PEERS:?}${N0:?} Peer(s) Did not even connect!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
fi
FAILED_PEERS=$(egrep "$(cat /tmp/node_data/addnodes.raw 2>/dev/null)" /tmp/debug.log 2>&1 | wc -l 2>&1)
printf '%b' "${LOG_DATE:?} Status() AddNode.Script ${G0:?}${FAILED_PEERS:?}${N0:?} Peer(s) Connected but failed!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

screen -X -S addnodes quit
killall screen
screen -wipe
exit
EOF
      # 60s 90s 120s 240s 300s 600s, 900s = 15 minutes
      # start adding nodes, inside screen session (timeout n seconds)
      timeout 900 screen -S addnodes -X -p 0 stuff $'bash /tmp/add_peers\n'
    fi
  fi
fi

### wallet information #########################################################

# get blockchain activity with mempool
if [[ "$WALLET_MEMPOOL" -gt "0" ]]; then
  # save activity value (1) to mempool.activity
  echo "1" >>"${LOG_DIR:?}"/node_data/mempool.activity 2>&1
else # save no activity value (0) to mempool.activity
  echo "0" >>"${LOG_DIR:?}"/node_data/mempool.activity 2>&1
fi
# reset mempool.activity after 1440 lines (1440min=1day)
if [[ "$(cat "${LOG_DIR:?}"/node_data/mempool.activity 2>/dev/null | wc -l 2>&1)" -gt "1440" ]] &>/dev/null; then
  # truncate mempool.activity
  truncate -s 0 "${LOG_DIR:?}"/node_data/mempool.activity &>/dev/null
fi

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "300" ]] &>/dev/null; then

  # collect wallet info, on every update (loop) from client
  "$WALLET_DIR"/trumpcoin-cli -datadir=./ -conf="$WALLET_DIR"/trumpcoin.conf getblockchaininfo 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/tmp/getblockchaininfo 2>&1
  "$WALLET_DIR"/trumpcoin-cli -datadir=./ -conf="$WALLET_DIR"/trumpcoin.conf getinfo 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/tmp/getinfo 2>&1
  "$WALLET_DIR"/trumpcoin-cli -datadir=./ -conf="$WALLET_DIR"/trumpcoin.conf getmempoolinfo 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/tmp/getmempoolinfo 2>&1
  "$WALLET_DIR"/trumpcoin-cli -datadir=./ -conf="$WALLET_DIR"/trumpcoin.conf getnetworkinfo 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/tmp/getnetworkinfo 2>&1
  "$WALLET_DIR"/trumpcoin-cli -datadir=./ -conf="$WALLET_DIR"/trumpcoin.conf getpatriotnodecount 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/tmp/getpatriotnodecount 2>&1
  "$WALLET_DIR"/trumpcoin-cli -datadir=./ -conf="$WALLET_DIR"/trumpcoin.conf getwalletinfo 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/tmp/getwalletinfo 2>&1
  "$WALLET_DIR"/trumpcoin-cli -datadir=./ -conf="$WALLET_DIR"/trumpcoin.conf listunspent 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/tmp/listunspent 2>&1
  "$WALLET_DIR"/trumpcoin-cli -datadir=./ -conf="$WALLET_DIR"/trumpcoin.conf getpeerinfo 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/tmp/getpeerinfo 2>&1
  # make sure data exist
  if grep -o "error: couldn't connect to server" "${LOG_DIR:?}"/node_data/tmp/getinfo &>/dev/null; then
    rm -R "${LOG_DIR:?}"/node_data/tmp/* &>/dev/null
  else # use existing data without any error(s)
    cat "${LOG_DIR:?}"/node_data/tmp/getblockchaininfo >"${LOG_DIR:?}"/node_data/getblockchaininfo 2>/dev/null
    cat "${LOG_DIR:?}"/node_data/tmp/getinfo >"${LOG_DIR:?}"/node_data/getinfo 2>/dev/null
    cat "${LOG_DIR:?}"/node_data/tmp/getmempoolinfo >"${LOG_DIR:?}"/node_data/getmempoolinfo 2>/dev/null
    cat "${LOG_DIR:?}"/node_data/tmp/getnetworkinfo >"${LOG_DIR:?}"/node_data/getnetworkinfo 2>/dev/null
    cat "${LOG_DIR:?}"/node_data/tmp/getpatriotnodecount >"${LOG_DIR:?}"/node_data/getpatriotnodecount 2>/dev/null
    cat "${LOG_DIR:?}"/node_data/tmp/getwalletinfo >"${LOG_DIR:?}"/node_data/getwalletinfo 2>/dev/null
    cat "${LOG_DIR:?}"/node_data/tmp/listunspent >"${LOG_DIR:?}"/node_data/listunspent 2>/dev/null
    cat "${LOG_DIR:?}"/node_data/tmp/getpeerinfo >"${LOG_DIR:?}"/node_data/getpeerinfo 2>/dev/null
  fi
fi

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "300" ]] &>/dev/null; then

  # get wallet version
  WALLET_VERSION=$("$WALLET_DIR"/trumpcoin-cli -version 2>&1 | egrep -o "v[0-9]+.[0-9]+.[0-9]+" 2>&1)
else # wallet version, grey, waiting on daemon data
  WALLET_VERSION="${GR:?}vLoading:?}${N0:?}"
fi

# running mainnet or testnet
if ! "$(grep "main" "${LOG_DIR:?}"/node_data/getblockchaininfo 2>&1)" -eq "main" &>/dev/null; then
  # mainnet
  WALLET_CHAIN="${G0:?}mainnet${N0:?}"
else # testnet
  WALLET_CHAIN="${C1:?}testnet${N0:?}"
fi

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -lt "300" ]] &>/dev/null; then
  # nonet
  WALLET_CHAIN="${CY:?}nonet${N0:?}"
fi

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "300" ]] &>/dev/null; then

  # loading is done
  RC_LOADING="${N0:?}"
  # logo turns yellow while running
  RC="${Y1:?}"
  # get blockchain headers
  WALLET_HEADS=$(grep "blocks" "${LOG_DIR:?}"/node_data/getblockchaininfo 2>&1 | grep -Eo "[0-9]+" 2>&1)
  # get blockchain block
  WALLET_BLOCK=$(grep "headers" "${LOG_DIR:?}"/node_data/getblockchaininfo 2>&1 | grep -Eo "[0-9]+" 2>&1)
  # calculate blockchain sync
  WALLET_SYNC=$(echo "100/$WALLET_HEADS*$WALLET_BLOCK" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
  # if progress equals 1, then 100% synced
  if [[ $(egrep -o "progress=1.000000" "$WALLET_LOG_DIR"/debug.log) ]] &>/dev/null; then
    WALLET_SYNC="100"
  fi
  # wallet sync var with percentage symbol
  WALLET_SYNC="${G1:?}${WALLET_SYNC:?}%${N0:?}"
  # non responsive, waiting on deamon data
elif [[ -z "$WALLET_HEADS" ]] &>/dev/null; then
  WALLET_HEADS="${GR:?}0${N0:?}"
  WALLET_BLOCK="${GR:?}0${N0:?}"
  WALLET_SYNC="${GR:?}0.00${N0:?}"
  RC_LOADING="${GR:?}        Loading${N0:?}"
else # wallet is loading/syncing
  WALLET_HEADS="${GR:?}0${N0:?}"
  WALLET_BLOCK="${GR:?}0${N0:?}"
  # loading while waiting on deamon data
  RC_LOADING="${GR:?}        Loading${N0:?}"
  # logo turns grey while loading
  RC="${GR:?}"
  # non responsive (loading)
  WALLET_SYNC="${GR:?}0.00%${N0:?}"
fi

# non responsive function (colors)
function wallet_nodes() {
  WALLET_NODES_TOTAL="${GR:?}0${N0:?}"
  WALLET_NODES_STABLE="${GR:?}0${N0:?}"
  WALLET_NODES_ENABLED="${GR:?}0${N0:?}"
  WALLET_NODES_INQUEUE="${GR:?}0${N0:?}"
  WALLET_PEERS_LATEST="${GR:?}0${N0:?}"
  WALLET_PEERS_OTHER="${GR:?}0${N0:?}"
  WALLET_PEERS_TOTAL="${GR:?}0${N0:?}"
}

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "300" ]] &>/dev/null; then

  # get wallet patriotnodes total
  WALLET_NODES_TOTAL=$(grep "total" "${LOG_DIR:?}"/node_data/getpatriotnodecount 2>&1 |
    egrep -o "[0-9]+" 2>&1)
  # get wallet patriotnodes stable
  WALLET_NODES_STABLE=$(grep "stable" "${LOG_DIR:?}"/node_data/getpatriotnodecount 2>&1 |
    egrep -o "[0-9]+" 2>&1)
  # get wallet patriotnodes enabled
  WALLET_NODES_ENABLED=$(grep "enabled" "${LOG_DIR:?}"/node_data/getpatriotnodecount 2>&1 |
    egrep -o "[0-9]+" 2>&1)
  # get wallet patriotnodes inqueue
  WALLET_NODES_INQUEUE=$(grep "inqueue" "${LOG_DIR:?}"/node_data/getpatriotnodecount 2>&1 |
    egrep -o "[0-9]+" 2>&1)

  # get wallet connections (peers) total
  WALLET_PEERS_TOTAL=$(grep "connections" "${LOG_DIR:?}"/node_data/getinfo 2>&1 |
    awk '{ print $2 }' 2>&1)
  # wallet peers total (no colors)
  WALLET_PEERS_TOTAL_N="$WALLET_PEERS_TOTAL"
  # wallet peers total (colors)
  WALLET_PEERS_TOTAL="${P1:?}$WALLET_PEERS_TOTAL${N0:?}"

  # get wallet connections latest (using wallet version)
  WALLET_PEERS_LATEST=$(grep "subver" "${LOG_DIR:?}"/node_data/getpeerinfo 2>&1 | egrep -o "$(echo "$WALLET_VERSION" 2>&1 | tr -d 'v' 2>&1)" 2>&1 | wc -l 2>&1)
  # get wallet connections other (not latest, probably older wallets)
  WALLET_PEERS_OTHER=$(grep "subver" "${LOG_DIR:?}"/node_data/getpeerinfo 2>&1 | egrep -o "[0-9]+.[0-9]+.[0-9]+" 2>&1 | tr -d 'v' 2>&1 | grep -v "$(echo "$WALLET_VERSION" | tr -d 'v' 2>&1)" 2>&1 | wc -l 2>&1)

  # wallet peers latest (colors)
  WALLET_PEERS_LATEST="${G1:?}${WALLET_PEERS_LATEST:?}${N0:?}"
  # wallet peers other (colors)
  WALLET_PEERS_OTHER="${G0:?}${WALLET_PEERS_OTHER:?}${N0:?}"

# non responsive (no colors)
elif [[ "$WALLET_PEERS_TOTAL_N" -eq "0" ]] &>/dev/null; then
  # non responsive
  wallet_nodes
elif [[ -z "$WALLET_PEERS_TOTAL_N" ]] &>/dev/null; then
  # non responsive
  wallet_nodes
else # non responsive
  wallet_nodes
fi

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "300" ]] &>/dev/null; then

  # get wallet balance
  WALLET_BALANCE=$(grep "balance" "${LOG_DIR:?}"/node_data/getinfo 2>&1 | egrep -o "[0-9]+.[0-9]+" 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
  # get unconfirmed balance
  WALLET_UNCONFIRMED=$(grep "unconfirmed_balance" "${LOG_DIR:?}"/node_data/getwalletinfo 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
  # get immature balance
  WALLET_IMMATURE=$(grep "immature_balance" "${LOG_DIR:?}"/node_data/getwalletinfo 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
  # get total balance, regardless of immature, unconfirmed values (combine them all)
  WALLET_BALANCE=$(echo "$WALLET_BALANCE+$WALLET_UNCONFIRMED+$WALLET_IMMATURE" | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
  # get wallet value
  WALLET_VALUE=$(echo "$(tail -1 "${LOG_DIR:?}"/node_data/ticker 2>&1)*$WALLET_BALANCE" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
else # non responsive (colors)
  WALLET_VALUE="${GR:?}0.00${N0:?}"
  WALLET_BALANCE="${GR:?}0.00${N0:?}"
  WALLET_IMMATURE="${GR:?}0.00${N0:?}"
  WALLET_UNCONFIRMED="${GR:?}0.00${N0:?}"
fi

# non responsive function (colors)
function wallet_balances() {
  WALLET_TICKER="${GR:?}0${N0:?}"
  WALLET_MEMPOOL="${GR:?}0${N0:?}"
  WALLET_TXCOUNT="${GR:?}0${N0:?}"
  WALLET_INPUTS="${GR:?}0${N0:?}"
}

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "369" ]] &>/dev/null; then

  # get wallet ticker.usd
  WALLET_TICKER=$(cat "${LOG_DIR:?}"/node_data/ticker 2>/dev/null)
  # get wallet mempool
  WALLET_MEMPOOL=$(grep "size" "${LOG_DIR:?}"/node_data/getmempoolinfo 2>&1 | egrep -o "[0-9]+" 2>&1)
  # get wallet txcount
  WALLET_TXCOUNT=$(grep "txcount" "${LOG_DIR:?}"/node_data/getwalletinfo 2>&1 | egrep -o "[0-9]+" 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
  # get wallet inputs
  WALLET_INPUTS=$(grep "address" "${LOG_DIR:?}"/node_data/listunspent 2>&1 | wc -l 2>&1)

# only zeros
elif [[ "$WALLET_TXCOUNT" -eq "0" ]] &>/dev/null; then
  # non responsive
  wallet_balances
elif [[ -z "$WALLET_TXCOUNT" ]] &>/dev/null; then
  # non responsive
  wallet_balances
else # non responsive
  wallet_balances
fi

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "369" ]] &>/dev/null; then

  # get last confirmation (smallest one)
  LAST_TX=$(grep "confirmations" "${LOG_DIR:?}"/node_data/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | sort -n 2>&1 | head -1 2>&1)
  # get last wallet txid with help of last_tx var
  WALLET_TXLAST=$(cat "${LOG_DIR:?}"/node_data/listunspent 2>/dev/null | tr -d ':' 2>&1 | grep -B8 "confirmations $LAST_TX" 2>&1 | grep "txid" 2>&1 | awk '{ print $2 }' 2>&1 | tail -1 2>&1)
else # non responsive
  LAST_TX="${N0:?}"
  # get random onion (cryptography)
  RANDOM_TX=$(openssl rand -base64 12 2>&1)
  WALLET_TXLAST="${GR:?}                       Loading transactions (tx) (${RANDOM_TX:0:11})${N0:?}"
fi

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "369" ]] &>/dev/null; then

  # save wallet stakes (addtowallet), remove duplicates
  # note: not perfect data of proof-of-work

  # make sure file exist before the fact
  touch "$LOG_DIR"/node_data/nodes.arp.value &>/dev/null
  touch /home/"$(whoami)"/staking &>/dev/null

  # get wallet stakes count
  egrep "AddToWallet [a0-z9]+  new" "$WALLET_LOG_DIR"/debug.log 2>&1 | awk '!a[$0]++' 2>&1 | egrep -c "AddToWallet [a0-z9]+  new" >"${LOG_DIR:?}"/node_data/staking.value 2>&1
  # get wallet proof of work value
  WALLET_POS=$(cat "${LOG_DIR:?}"/node_data/staking.value 2>/dev/null)
  # count saved vs wallet stakes
  SAVED_POS=$(cat /home/"$(whoami)"/staking 2>/dev/null | wc -l 2>&1)
  WALLET_STAKES="${WALLET_POS:?}"
  # wallet pos value greater then saved pos value
  if [[ "$WALLET_POS" -gt "$SAVED_POS" ]] &>/dev/null; then
    # get addtowallet, remove duplicates
    egrep "AddToWallet [a0-z9]+  new" "$WALLET_LOG_DIR"/debug.log 2>&1 | awk '!a[$0]++' >/home/"$(whoami)"/staking 2>&1
    printf '%b' "${LOG_DATE:?} Status() Proof.Of.Work: Saved ${G1:?}${WALLET_POS:?}${GR:?} :: ${N0:?}Proof of work data!${GR:?} :: ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
else # non responsive (colors)
  WALLET_STAKES="${GR:?}0${N0:?}"
fi

# if ticker is found
if [ -f "${LOG_DIR:?}"/node_data/ticker ] &>/dev/null; then
  # wallet pos status
  if [[ "$(grep "Staking Active" "${LOG_DIR:?}"/node_data/getinfo 2>&1)" ]] &>/dev/null; then
    # pos active
    POS_STATUS="${G1:?}S${N0:?}"
    # balance is staking, highlight balance, stakes and inputs (colors)
    WALLET_BALANCE="${G1:?}${WALLET_BALANCE:?}${N0:?}"
    WALLET_STAKES="${G1:?}${WALLET_STAKES:?}${N0:?}"
    WALLET_INPUTS="${G1:?}${WALLET_INPUTS:?}${N0:?}"
  else # pos not active (colors) waiting on daemon data
    POS_STATUS="${GR:?}S${N0:?}"
    WALLET_BALANCE="${GR:?}${WALLET_BALANCE:?}${N0:?}"
    WALLET_STAKES="${GR:?}${WALLET_STAKES:?}${N0:?}"
    WALLET_INPUTS="${GR:?}${WALLET_INPUTS:?}${N0:?}"
  fi
else # pos not active (colors) waiting on daemon data
  POS_STATUS="${GR:?}S${N0:?}"
  WALLET_BALANCE="${GR:?}${WALLET_BALANCE:?}${N0:?}"
  WALLET_STAKES="${GR:?}${WALLET_STAKES:?}${N0:?}"
  WALLET_INPUTS="${GR:?}${WALLET_INPUTS:?}${N0:?}"
fi

### clean up debug.log, peers.dat (truncate) keep pos around ###################

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "600" ]] &>/dev/null; then

  # note: heavy reading, do interval reading with date:time
  if [[ "$(date '+%T' 2>&1 | egrep "[0-9]+:[0-9]+5:[0-9]+|[0-9]+:[0-9]+0:[0-9]+" 2>&1)" ]] &>/dev/null; then

    # save proof of work data from debug.log
    # note: not perfect data of proof-of-work
    # count saved vs wallet stakes
    SAVED_POS=$(cat /home/"$(whoami)"/staking 2>/dev/null | wc -l 2>&1)
    # get wallet proof of work value
    WALLET_POS=$(cat "${LOG_DIR:?}"/node_data/staking.value 2>/dev/null)
    # if wallet pos is less than saved pos
    if [[ "$WALLET_POS" -lt "$SAVED_POS" ]] &>/dev/null; then
      # restore missing proof of work data
      cat /home/"$(whoami)"/staking 2>/dev/null | awk '!a[$0]++' >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
      printf '%b' "${LOG_DATE:?} Status() Proof.Of.Work: Restored ${G1:?}${SAVED_POS:?}${GR:?} :: ${N0:?}Proof of work data!${GR:?} :: ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    fi
  fi
fi

# greater than n seconds, continue
if [[ "$(uptime_daemon)" -gt "369" ]] &>/dev/null; then

  # note: heavy reading, do interval reading with date:time
  if [[ "$(date +%H%M 2>&1 | grep -Eo "0000" 2>&1)" ]] &>/dev/null; then
    if [[ "$KEEP_BACKUPS" -eq "0" ]] &>/dev/null; then
      # remove old backups, ruled by configuration
      rm -r "${WALLET_DIR:?}"/backups/* &>/dev/null
      printf '%b' "${LOG_DATE:?} Status() Clean.remove() Deleting wallet backups${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    fi
    # remove old files
    rm "${LOG_DIR:?}"/node_data/onion &>/dev/null
    rm "${LOG_DIR:?}"/node_data/getwan &>/dev/null
    # truncate debug.log
    truncate -s 0 "${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${LOG_DATE:?} Status() Clean.truncate debug, onion${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

### timeline ###################################################################

# if rpc in warm-up, loading block index, wait
if [ -f "${LOG_DIR:?}"/node_data/getblockchaininfo ] &>/dev/null; then

  # random start number
  RANDOM_TIMELINE=$((((RANDOM % 13) + 1)))

  # difficulty
  if [ "$RANDOM_TIMELINE" -eq "1" ] &>/dev/null; then
    TIMELINE=$(grep "difficulty" "${LOG_DIR:?}"/node_data/getinfo 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
    TIMELINE="Difficulty $TIMELINE"
  # patriotnodes
  elif [ "$RANDOM_TIMELINE" -eq "2" ] &>/dev/null; then
    TIMELINE="Patriotnodes ${N0:?}${WALLET_NODES_STABLE:?}${N0:?}/${G1:?}${WALLET_NODES_TOTAL:?}${N0:?}/${G0:?}${WALLET_NODES_ENABLED:?}${N0:?}/${GR:?}${WALLET_NODES_INQUEUE:?}${N0:?}"
  # moneysupply
  elif [ "$RANDOM_TIMELINE" -eq "3" ] &>/dev/null; then
    TIMELINE=$(grep "moneysupply" "${LOG_DIR:?}"/node_data/getinfo 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1 | rev 2>&1 | sed "s#[[:digit:]]\{3\}#&,#g" 2>&1 | rev 2>&1 | sed 's/^,//g' 2>&1)
    TIMELINE="Moneysupply $TIMELINE${N0:?}"
  # unconfirmed_balance
  elif [ "$RANDOM_TIMELINE" -eq "4" ] &>/dev/null; then
    WALLET_UNCONFIRMED_VALUE=$(echo "$WALLET_UNCONFIRMED*$(tail -1 "${LOG_DIR:?}"/node_data/ticker 2>&1)" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1 | tail -1 2>&1)
    TIMELINE="Unconfirmed $WALLET_UNCONFIRMED ${GR:?}$WALLET_UNCONFIRMED_VALUE USD${N0:?}"
  # immature_balance
  elif [ "$RANDOM_TIMELINE" -eq "5" ] &>/dev/null; then
    WALLET_IMMATURE_VALUE=$(echo "$WALLET_IMMATURE*$(tail -1 "${LOG_DIR:?}"/node_data/ticker 2>&1)" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1 | tail -1 2>&1)
    TIMELINE="Immature $WALLET_IMMATURE ${GR:?}$WALLET_IMMATURE_VALUE USD${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "6" ] &>/dev/null; then
    # lowest confirmation
    TIMELINE_CONF=$(grep "confirmations" "${LOG_DIR:?}"/node_data/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | sort -n 2>&1 | head -1 2>&1)
    # calculate seconds
    TIMELINE_SEC=$(echo "$TIMELINE_CONF*60" 2>&1 | bc -l 2>&1 | awk -F. '{ print $1 }' 2>&1)
    # calculate seconds into age
    INPUT_AGE=$(printf '%dh:%dm' $(("$TIMELINE_SEC/3600")) $(("$TIMELINE_SEC%3600/60")))
    INPUT_AGE_D=$(echo "$(echo "$INPUT_AGE" 2>&1 | egrep -o "[0-9]+h" 2>&1 | tr -d 'h' 2>&1)/24" 2>&1 | bc 2>&1)
    TIMELINE="New Input $TIMELINE_CONF (${INPUT_AGE_D:?}d) ${GR:?}$INPUT_AGE${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "7" ] &>/dev/null; then
    # highest confirmation
    TIMELINE_CONF=$(grep "confirmations" "${LOG_DIR:?}"/node_data/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | sort -n 2>&1 | tail -1 2>&1)
    # calculate seconds
    TIMELINE_SEC=$(echo "$TIMELINE_CONF*60" 2>&1 | bc -l 2>&1 | awk -F. '{ print $1 }' 2>&1)
    # calculate seconds into age
    INPUT_AGE=$(printf '%dh:%dm' $(("$TIMELINE_SEC/3600")) $(("$TIMELINE_SEC%3600/60")))
    INPUT_AGE_D=$(echo "$(echo "$INPUT_AGE" 2>&1 | egrep -o "[0-9]+h" 2>&1 | tr -d 'h' 2>&1)/24" 2>&1 | bc 2>&1)
    TIMELINE="Old Input $TIMELINE_CONF (${INPUT_AGE_D:?}d) ${GR:?}$INPUT_AGE${N0:?}"
    # average confirmation
  elif [ "$RANDOM_TIMELINE" -eq "8" ] &>/dev/null; then
    UNSPENT_COUNT=$(grep "confirmations" "${LOG_DIR:?}"/node_data/listunspent 2>&1 | wc -l 2>&1)
    TIMELINE=$(grep "confirmations" "${LOG_DIR:?}"/node_data/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ SUM += $1} END { print SUM }' 2>&1)
    # average calculated
    TIMELINE_AVG=$(echo "$TIMELINE/$UNSPENT_COUNT" 2>&1 | bc 2>&1)
    # calculate seconds
    TIMELINE_SEC=$(echo "$TIMELINE_AVG*60" 2>&1 | bc -l 2>&1 | awk -F. '{ print $1 }' 2>&1)
    # calculate seconds into age
    INPUT_AGE=$(printf '%dh:%dm' $(("$TIMELINE_SEC/3600")) $(("$TIMELINE_SEC%3600/60")))
    # save the value
    echo "${INPUT_AGE:?}" >"${LOG_DIR:?}"/node_data/avgconfirmation.value
    INPUT_AGE_D=$(echo "$(echo "$INPUT_AGE" 2>&1 | egrep -o "[0-9]+h" 2>&1 | tr -d 'h' 2>&1)/24" 2>&1 | bc 2>&1)
    TIMELINE="Average $TIMELINE_AVG (${INPUT_AGE_D:?}d) ${GR:?}$INPUT_AGE${N0:?}"
    # wallet value
  elif [ "$RANDOM_TIMELINE" -eq "9" ] &>/dev/null; then
    TIMELINE="Value ${WALLET_VALUE:?} USD ${GR:?}$WALLET_TICKER${N0:?}"
    # highest input amount
  elif [ "$RANDOM_TIMELINE" -eq "10" ] &>/dev/null; then
    TIMELINE=$(grep "amount" "${LOG_DIR:?}"/node_data/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | sort -n 2>&1 | tail -1 2>&1)
    TIMELINE="Highest Input $TIMELINE"
    # lowest input amount
  elif [ "$RANDOM_TIMELINE" -eq "11" ] &>/dev/null; then
    TIMELINE=$(grep "amount" "${LOG_DIR:?}"/node_data/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | sort -n 2>&1 | head -1 2>&1)
    TIMELINE="Lowest Input $TIMELINE"
    # daemon uptime
  elif [ "$RANDOM_TIMELINE" -eq "12" ] &>/dev/null; then
    TIMELINE=$(printf '%dh:%dm:%ds\n' $(("$(uptime_daemon)/3600")) $(("$(uptime_daemon)%3600/60")) $(("$(uptime_daemon)%60")))
    TIMELINE_DAYS=$(echo "$(uptime_daemon)/86400" 2>&1 | bc 2>&1)
    TIMELINE="Uptime (${TIMELINE_DAYS:?}d) ${GR:?}$TIMELINE${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "13" ] &>/dev/null; then
    # create a list this time
    echo "$WALLET_PEERS_TOTAL_N" >>"${LOG_DIR:?}"/node_data/connections
    # highest peer count
    HIGH_P2P=$(cat "${LOG_DIR:?}"/node_data/connections 2>/dev/null | sort -n 2>&1 | tail -1 2>&1)
    # lowest peer count
    LOWS_P2P=$(cat "${LOG_DIR:?}"/node_data/connections 2>/dev/null | sort -n 2>&1 | head -1 2>&1)
    TIMELINE="Low/High P2P $LOWS_P2P/$HIGH_P2P"
  elif [ "$RANDOM_TIMELINE" -eq "14" ] &>/dev/null; then
    TIMELINE_ACTIVE=$(grep "1" "${LOG_DIR:?}"/node_data/mempool.activity 2>&1 | wc -l 2>&1)
    TIMELINE_NOACTIVE=$(grep "0" "${LOG_DIR:?}"/node_data/mempool.activity 2>&1 | wc -l 2>&1)
    TIMELINE_PERC_ACTIVE=$(echo "100/$TIMELINE_ACTIVE*1440" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
    TIMELINE_PERC_NOACTIVE=$(echo "100/$TIMELINE_NOACTIVE*1440" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
    TIMELINE_PERC_ACTIVE="${TIMELINE_PERC_ACTIVE:?}%"
    TIMELINE_PERC_NOACTIVE="${TIMELINE_PERC_NOACTIVE:?}%"
    TIMELINE="${N0:?}Blockchain Activity ${TIMELINE_PERC_ACTIVE:?}${N0:?} Dead ${GR:?}${TIMELINE_PERC_NOACTIVE:?}${N0:?}"
  fi
else # wait on wallet (--donald john trump quotes - art of the deal)
  # random start number
  RANDOM_TIMELINE=$((((RANDOM % 10) + 1)))
  # quotes - art of the deal
  if [ "$RANDOM_TIMELINE" -eq "1" ] &>/dev/null; then
    TIMELINE="${GR}Think big${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "2" ] &>/dev/null; then
    TIMELINE="${GR}Maximize your options${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "3" ] &>/dev/null; then
    TIMELINE="${GR}Know your market${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "4" ] &>/dev/null; then
    TIMELINE="${GR}Use your leverage${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "5" ] &>/dev/null; then
    TIMELINE="${GR}Enhance your location${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "6" ] &>/dev/null; then
    TIMELINE="${GR}Get the word out${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "7" ] &>/dev/null; then
    TIMELINE="${GR}Fight back${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "8" ] &>/dev/null; then
    TIMELINE="${GR}Deliver the goods${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "9" ] &>/dev/null; then
    TIMELINE="${GR}Contain the costs${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "10" ] &>/dev/null; then
    TIMELINE="${GR}Have fun${N0:?}"
  fi
fi

### theme ######################################################################

if [[ "$DARKMODE" -eq "1" ]] &>/dev/null; then
  # darkmode theme (grey)
  RC="${GR:?}"
  TH="${RC:?}D${N0:?}"
else # default theme (yellow)
  RC="${Y1:?}"
  TH="${RC:?}D${N0:?}"
fi

# END
