#!/bin/bash

# By Rainman
# V20221602
# 1.6.3.4

# shellcheck disable=SC2034  # Unused variables left for readability

# script version for dashbord
VERSION="v1.6.3.4"

source /usr/local/bin/include/pinode.conf
source /usr/local/bin/include/color

### folders, daemon uptime, logs ###############################################

# create directories, ruled by configuration
mkdir "${LOG_DIR:?}"/node_data &>/dev/null
mkdir "${LOG_DIR:?}"/node_data/peers &>/dev/null
mkdir "${LOG_DIR:?}"/node_data/stats &>/dev/null
mkdir "${LOG_DIR:?}"/node_data/client &>/dev/null
mkdir "${LOG_DIR:?}"/node_data/client/tmp &>/dev/null

# wait on node (daemon) to start
until pidof "${WALLET_DAEMON:?}" 2>&1 | wc -w 2>&1 | egrep "1" &>/dev/null; do

  RANDOM_PID=$((((RANDOM % 9999) + 1)))
  clear
  printf '%b' "waiting on wallet (${GR:?}${RANDOM_PID:?}${N0:?}) daemon..${GR:?}

  Honk Honk  . .. . .,
   __________________ll___
  | *FUCK TRUDEAU ||l ''|'\__,_
  |_______________|||___|__|__|]
  (@)@)*************(@)(@)**(@)${N0:?}\n"
  sleep 2
  # create debug.log
  touch "${WALLET_LOG_DIR:?}"/debug.log &>/dev/null
  # date for logs
  LC_ALL=de_US.utf8 date '+%Y-%m-%dT%TZ' >"${LOG_DIR:?}"/node_data/stats/date 2>&1
  # date check
  LC_ALL=de_US.utf8 date '+%T' >"${LOG_DIR:?}"/node_data/stats/date.check 2>&1
  # get load
  uptime 2>&1 | xargs 2>&1 | egrep -o "[0-9]+.[0-9]+, [0-9]+.[0-9]+, [0-9]+.[0-9]+" >"${LOG_DIR:?}"/node_data/stats/load 2>&1
done

# wallet daemon uptime in seconds
function uptime_daemon() {
  PID="$(pidof "${WALLET_DAEMON:?}" 2>&1)"
  HZ=$(getconf CLK_TCK 2>&1)
  UPTIME_CMD=$(awk '{print $1}' </proc/uptime)
  STARTTIME=$(awk '{print $22}' </proc/"$PID"/stat)
  echo $(("${UPTIME_CMD%.*}" - "$STARTTIME" / "$HZ"))
}
# create uptime
echo "$(uptime_daemon 2>&1)" 2>&1 | tr -d '-' >"${LOG_DIR:?}"/node_data/uptime 2>&1

# get system uptime information
uptime 2>&1 | xargs >"${LOG_DIR:?}"/node_data/stats/uptime 2>&1

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "1" ]] &>/dev/null; then

  # tail last line in debug.log
  LAST_LOG=$(tail -n 1 "${WALLET_LOG_DIR:?}"/debug.log 2>&1)
  # get log size from debug.log
  LOG_SIZE=$(ls -lS --block-size=M "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | awk '{ print $5 }' 2>&1)
  # log max :n characters, w log size
  LAST_LOG="${LAST_LOG:0:188} log=$LOG_SIZE"
else # log lines (tail debug)
  LAST_LOG=$(tail -n 1 "${WALLET_LOG_DIR:?}"/debug.log 2>&1)
  # log max :n characters, no log size
  LAST_LOG="${LAST_LOG:0:188}"
fi

if [[ -z "$LAST_LOG" ]] &>/dev/null; then
  # non responsive
  LAST_LOG="${N0:?}"
fi

# clock, log date, log check, waiting orders, log size #########################

LOG_DATE=$(cat "${LOG_DIR:?}"/node_data/stats/date 2>/dev/null)

if [[ -z "$LOG_DATE" ]] &>/dev/null; then
  LOG_DATE=$(LC_ALL=de_US.utf8 date '+%Y-%m-%dT%TZ' 2>&1)
fi

if [[ "$(echo "$LOG_SIZE" 2>&1 | egrep -o "[0-9]+" 2>&1)" -gt "20" ]] &>/dev/null; then
  # log too big (probably syncing)
  truncate -s 0 "${WALLET_LOG_DIR:?}"/debug.log &>/dev/null
  printf '%b' "${LOG_DATE:?} Status() DebuglogSize() truncate debug.log, it's too big! (probably syncing) ${CY:?}${LOG_SIZE:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
fi

# time - date, trim extra spaces with xargs
CLOCK=$(LC_ALL=de_US.utf8 date '+%H:%M:%S' 2>&1)

# date for logs
LC_ALL=de_US.utf8 date '+%Y-%m-%dT%TZ' >"${LOG_DIR:?}"/node_data/stats/date 2>&1

# date check
LC_ALL=de_US.utf8 date '+%T' >"${LOG_DIR:?}"/node_data/stats/date.check 2>&1
LOG_CHECK=$(cat "${LOG_DIR:?}"/node_data/stats/date.check 2>/dev/null)

if [[ -z "$LOG_CHECK" ]] &>/dev/null; then
  LOG_CHECK=$(LC_ALL=de_US.utf8 date '+%T' >"${LOG_DIR:?}"/node_data/stats/date.check 2>&1)
fi

# waiting values
WAIT_TIME=$(head -1 "${WALLET_DIR:?}"/wait 2>&1)
WAIT_TIME_BLOCK=$(tail -1 "${WALLET_DIR:?}"/wait 2>&1)

# non responsive, use default timer
if [[ -z "$WAIT_TIME" ]] &>/dev/null; then
  WAIT_TIME="360"
  echo "${WAIT_TIME:?}" >"${WALLET_DIR:?}"/wait
fi
if [[ -z "$WAIT_TIME_BLOCK" ]] &>/dev/null; then
  WAIT_TIME_BLOCK="420"
  echo "${WAIT_TIME_BLOCK:?}" >>"${WALLET_DIR:?}"/wait
fi

### system information, load, user, cpu temp ###################################

# get load
uptime 2>&1 | xargs 2>&1 | egrep -o "[0-9]+.[0-9]+, [0-9]+.[0-9]+, [0-9]+.[0-9]+" 2>&1 | sed 's/\([0-9]\),/\1./g' >"${LOG_DIR:?}"/node_data/stats/load 2>&1
LOAD=$(cat "${LOG_DIR:?}"/node_data/stats/load 2>/dev/null | egrep -o "[0-9]+.[0-9]+" | xargs 2>&1)

# remove empty files, load
if [ ! -s "${LOG_DIR:?}"/node_data/stats/load ] &>/dev/null; then
  # try again
  uptime 2>&1 | xargs 2>&1 | egrep -o "[0-9]+.[0-9]+, [0-9]+.[0-9]+, [0-9]+.[0-9]+" >"${LOG_DIR:?}"/node_data/stats/load 2>&1
fi

if [[ -z "$LOAD" ]] &>/dev/null; then
  # non responsive
  LOAD=$(uptime 2>&1 | xargs 2>&1 | egrep -o "[0-9]+.[0-9]+, [0-9]+.[0-9]+, [0-9]+.[0-9]+" 2>&1 | sed 's/\([0-9]\),/\1./g' 2>&1 | egrep -o "[0-9]+.[0-9]+" | xargs 2>&1)
fi

# do this once (lscpu values)
if [[ ! -f "${LOG_DIR:?}"/node_data/stats/cpuinfo ]] &>/dev/null; then

  # do this once (cpu speed, wait time)
  if [ ! -f "${LOG_DIR:?}"/node_data/stats/lscpu ] &>/dev/null; then
    lscpu >"${LOG_DIR:?}"/node_data/stats/lscpu 2>&1
    cat "${LOG_DIR:?}"/node_data/stats/lscpu 2>/dev/null | grep "CPU max" 2>&1 | awk -F. '{ print $1 }' 2>&1 | awk '{ print $4 }' >"${LOG_DIR:?}"/node_data/stats/cpuspeed 2>&1
  fi

  # get cpu count, threads, cores, vendor id, model and speed
  CPUS=$(grep "CPU(s):" "${LOG_DIR:?}"/node_data/stats/lscpu 2>&1 | awk '{ print $2 }' 2>&1)
  THREADS=$(grep "Thread(s) per core:" "${LOG_DIR:?}"/node_data/stats/lscpu 2>&1 | awk '{ print $4 }' 2>&1)
  CORES=$(grep "Core(s) per socket:" "${LOG_DIR:?}"/node_data/stats/lscpu 2>&1 | awk '{ print $4 }' 2>&1)
  VENDORID=$(grep "Vendor ID:" "${LOG_DIR:?}"/node_data/stats/lscpu 2>&1 | awk '{ print $3 }' 2>&1)
  MODEL=$(grep "Model name:" "${LOG_DIR:?}"/node_data/stats/lscpu 2>&1 | awk '{ print $3 }' 2>&1)
  SPEED=$(echo "$(grep "CPU max MHz:" "${LOG_DIR:?}"/node_data/stats/lscpu 2>&1 | awk '{ print $4 }' 2>&1)/1000" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
  # create cpu information
  echo "CPUs ($CPUS) ${GR:?}$THREADS/$CORES${N0:?} - $VENDORID ${GR:?}$MODEL${N0:?} ${SPEED:?}GHz" >"${LOG_DIR:?}"/node_data/stats/cpuinfo 2>&1
fi

# get system uptime
awk -F. ' {print $1 }' /proc/uptime >"${LOG_DIR:?}"/node_data/stats/system.uptime 2>&1
SYS_UPTIME=$(printf '%dh:%dm:%ds\n' $(("$(cat "${LOG_DIR:?}"/node_data/stats/system.uptime 2>/dev/null)/3600")) $(("$(cat "${LOG_DIR:?}"/node_data/stats/system.uptime 2>/dev/null)%3600/60")) $(("$(cat "${LOG_DIR:?}"/node_data/stats/system.uptime 2>/dev/null)%60")))
SYS_UPTIME_DAYS=$(echo "$(cat "${LOG_DIR:?}"/node_data/stats/system.uptime 2>/dev/null)/86400" 2>&1 | bc 2>&1)
SYS_UPTIME="System (${SYS_UPTIME_DAYS:?}d) ${GR:?}${SYS_UPTIME:?}${N0:?}"

# create uname -a
uname -a >"${LOG_DIR:?}"/node_data/uname

# get system user
USER=$(whoami 2>&1 | awk '{ print $1 }' 2>&1)

if cat "${LOG_DIR:?}"/node_data/uname 2>/dev/null | egrep "armv7l|aarch64" &>/dev/null; then
  # get cpu temp, celcius, fahrenheit, (raspberry pi)
  CPU_RAW_TEMP=$(cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null)
else
  CPU_RAW_TEMP="0"
fi
# calculate celcius and fahrenheit
CELCIUS=$(echo "$CPU_RAW_TEMP/100*0.1" 2>&1 | bc -l 2>&1 | awk '{ printf "%.1f\n", $1 }' 2>&1)
FAHRENHEIT=$(echo "scale=2;((9/5) * $CELCIUS) + 32" 2>&1 | bc 2>&1 | awk '{ printf "%.1f\n", $1 }' 2>&1)

CPU_CTEMP="${CELCIUS:?}"
CPU_FTEMP="${FAHRENHEIT:?}"

### system memory ##############################################################

# get total Memory
TOTAL_MEM=$(free --mega 2>&1 | grep "Mem" 2>&1 | awk '{ print $2 }' 2>&1)
TOTAL_SWAP=$(free --mega 2>&1 | grep "Swap" 2>&1 | awk '{ print $2 }' 2>&1)
# get free Memory
FREE_MEM=$(free --mega 2>&1 | grep "Mem" 2>&1 | awk '{ print $4 }' 2>&1)
FREE_SWAP=$(free --mega 2>&1 | grep "Swap" 2>&1 | awk '{ print $4 }' 2>&1)
# calculate
TOTAL_MEM=$(echo "$TOTAL_MEM+$TOTAL_SWAP" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
FREE_MEM=$(echo "$FREE_MEM+$FREE_SWAP" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
# total and free memory (rrdtool, no color)
TOTAL_MEM_N="$TOTAL_MEM"
FREE_MEM_N="$FREE_MEM"
# total and free (color)
TOTAL_MEM="${G0:?}$TOTAL_MEM${N0:?}"
FREE_MEM="${G1:?}$FREE_MEM${N0:?}"

### system space ###############################################################

# get used space, disregard boot
USED_HDD=$(df -k 2>&1 | sort -n 2>&1 | grep -v "boot" 2>&1 | head -1 2>&1 | awk '{ print $3 }' 2>&1)
# calculate --block-size=1k
USED_HDD=$(echo "$USED_HDD*1024" 2>&1 | bc -l 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
# human-readable format
USED_HDD=$(numfmt --to iec --format "%8.3f" "$USED_HDD" 2>&1 | xargs 2>&1)
# get used hdd percentage
USED_HDD_P=$(df -k 2>&1 | sort -n 2>&1 | grep -v "boot" 2>&1 | head -1 2>&1 | awk '{ print $5 }' 2>&1)
# get used hdd (color)
USED_HDD="${G1:?}${USED_HDD:?}${N0:?}"

### network - download and upload ##############################################

# save ifconfig, iwconfig values to ifconfig, iwconfig
ifconfig 2>&1 | egrep -A8 "wlan[0-9]+|eth[0-9]+" >"${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1
iwconfig 2>&1 | egrep -A8 "wlan[0-9]+|eth[0-9]+" >"${LOG_DIR:?}"/node_data/stats/iwconfig 2>&1

# get download from wlan(*) - eth(*)
DOWNLOAD=$(egrep "RX packets [0-9]+  bytes [0-9]+" "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1 | awk '{ print $5 }' 2>&1 | sort -n 2>&1 | tail -1 2>&1)
# get upload from wlan(*) - eth(*)
UPLOAD=$(egrep "TX packets [0-9]+  bytes [0-9]+" "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1 | awk '{ print $5 }' 2>&1 | sort -n 2>&1 | tail -1 2>&1)
# human-readable format
DOWNLOAD=$(numfmt --to iec --format "%8.3f" "$DOWNLOAD" 2>&1 | xargs 2>&1)
UPLOAD=$(numfmt --to iec --format "%8.3f" "$UPLOAD" 2>&1 | xargs 2>&1)

# if non responsive
IP_ADDRESS="${GR:?}0.0.0.0${N0:?}"
# interface icon (top right)
INTERFACE=$(egrep "wlan*|eth*" "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1 | grep -B1 "inet" 2>&1 | egrep -o "wlan[0-9]+|eth[0-9]+" 2>&1)
# get interface
IFCONFIG="${INTERFACE:?}"
# get ip address from interface
IP_ADDRESS=$(cat "${LOG_DIR:?}"/node_data/stats/ifconfig 2>/dev/null | egrep "inet " 2>&1 | grep -vwE "127.0.0.1" 2>&1 | awk '{ print $2 }' 2>&1 | head -1 2>&1)
# get ip address (no color)
IP_ADDRESS_N="${IP_ADDRESS:?}"
# save ip address value
echo "${IP_ADDRESS_N:?}" >"${LOG_DIR:?}"/node_data/stats/ip_address 2>&1
# get ip address (color)
IP_ADDRESS="${C1:?}${IP_ADDRESS:?}${N0:?}"

### wan address ################################################################

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  # get wan address, if missing
  if [ ! -f "${WALLET_DIR:?}"/getwan ] &>/dev/null; then
    # get my wan ip from myip.opendns.com -> resolver1.opendns.com
    host myip.opendns.com resolver1.opendns.com >"${WALLET_DIR:?}"/getwan 2>&1
    printf '%b' "${LOG_DATE:?} Status() GetWan.Data(): Found Wan Address (${CY:?}$(grep "address" "${WALLET_DIR:?}"/getwan 2>&1 | egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1)${N0:?})${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    # get public ip address
    PUBLIC_IP=$(grep "address" "${WALLET_DIR:?}"/getwan 2>&1 | egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1)
    # public ip (color)
    PUBLIC_IP="${C1:?}${PUBLIC_IP:?}${N0:?}"
  fi
else # output localhost (127.0.0.1) if not found
  # waiting on daemon data (color)
  PUBLIC_IP="${GR:?}127.0.0.1${N0:?}"
fi

### tor ########################################################################

# remove empty files, onion
if [ ! -s "${WALLET_DIR:?}"/onion ] &>/dev/null; then
  rm "${WALLET_DIR:?}"/onion &>/dev/null
fi

# get tor status
if egrep "proxy: [0-9]+.[0-9]+.[0-9]+.[0-9]+:9050" "${LOG_DIR:?}"/node_data/client/getinfo &>/dev/null; then

  TOR_ICON="${P1:?}P$N0"
  # running proxy (tor), do this once
  if [ ! -f "${WALLET_DIR:?}"/onion ] &>/dev/null; then

    if egrep -o "[a0-z9]+.onion" "${WALLET_LOG_DIR:?}"/debug.log &>/dev/null; then
      egrep -o "[a0-z9]+.onion" "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | tail -1 >"${WALLET_DIR:?}"/onion 2>&1

      printf '%b' "${LOG_DATE:?} Status() GetOnionData() Found Onion Address! (${P1:?}$(cat "${WALLET_DIR:?}"/onion 2>/dev/null)${N0:?})${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    fi

    # get onion address
    PUBLIC_IP=$(cat "${WALLET_DIR:?}"/onion 2>/dev/null)
    # output onion address (short version)
    PUBLIC_IP="${P1:?}${PUBLIC_IP:0:8}...onion${N0:?}"

    # get onion address from debug.log
    if ! egrep -o "[a0-z9]+.onion" "${WALLET_LOG_DIR:?}"/debug.log &>/dev/null; then
      # not working, use urandom
      tr -dc 'a-z' </dev/urandom 2>&1 | head -c 64 2>&1 | rev >"${WALLET_DIR:?}"/onion 2>&1

      printf '%b' "${LOG_DATE:?} Status() GetOnionData() No Onion Address found! Using random ($(cat "${WALLET_DIR:?}"/onion 2>/dev/null))${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    fi
  fi

  PUBLIC_IP=$(cat "${WALLET_DIR:?}"/onion 2>/dev/null)
  PUBLIC_IP="${P1:?}${PUBLIC_IP:0:8}...onion${N0:?}"

else # tor icon (top right)
  TOR_ICON="${GR:?}P$N0"
  # tor public ip while waiting on data
  PUBLIC_IP="${GR:?}127.0.0.1$N0"
fi

if [[ "$HIDE_WAN" -eq "1" ]] &>/dev/null; then
  # hide wan address
  PUBLIC_IP="${GR:?}127.0.0.1$N0"
fi

### coinmarketcap data #########################################################

# if success, create files, reset requests.cmc file
if grep "success" "${LOG_DIR:?}"/node_data/requests.cmc &>/dev/null; then

  # get token price
  grep "Freedomcoin Price" "${LOG_DIR:?}"/node_data/stats/raw.coinmcap 2>&1 | tr -d '$|,' 2>&1 | xargs 2>&1 | egrep -o "Price [0-9]+.[0-9]+" 2>&1 | awk '{ print $2 }' 2>&1 | tail -1 >"${LOG_DIR:?}"/node_data/stats/price.cmc 2>&1
  # get token volume
  grep "Trading Volume24h" "${LOG_DIR:?}"/node_data/stats/raw.coinmcap 2>&1 | tail -1 2>&1 | awk '{ print $3 }' 2>&1 | tr -d '$|,' >"${LOG_DIR:?}"/node_data/stats/volume.cmc 2>&1
  # get token rank
  grep "Market Rank" "${LOG_DIR:?}"/node_data/stats/raw.coinmcap 2>&1 | tail -1 2>&1 | tr -d '#' 2>&1 | awk '{ print $3 }' >"${LOG_DIR:?}"/node_data/stats/rank.cmc 2>&1
  # get token watchlist
  grep "watchlists" "${LOG_DIR:?}"/node_data/stats/raw.coinmcap 2>&1 | tr -d ',' 2>&1 | awk '{ print $2 }' >"${LOG_DIR:?}"/node_data/stats/watchers.cmc 2>&1

  # coinmarketcap api values
  API_PRICE_CMC=$(cat "${LOG_DIR:?}"/node_data/stats/price.cmc 2>/dev/null | awk '{ printf "%.4f\n", $1 }' 2>&1)
  API_VOLUME_CMC=$(cat "${LOG_DIR:?}"/node_data/stats/volume.cmc 2>/dev/null | awk '{ printf "%.2f\n", $1 }' 2>&1)
  API_RANK_CMC=$(cat "${LOG_DIR:?}"/node_data/stats/rank.cmc 2>/dev/null | awk '{ printf "%.0f\n", $1 }' 2>&1)
  API_WATCH_CMC=$(cat "${LOG_DIR:?}"/node_data/stats/watchers.cmc 2>/dev/null | awk '{ printf "%.0f\n", $1 }' 2>&1)

  # greater than n seconds, continue
  if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "420" ]] &>/dev/null; then

    printf '%b' "${GR:?}${LOG_DATE:?} Status() - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${LOG_DATE:?} Status() CoinMCap.API() Found ${G1:?}${API_PRICE_CMC:?}${N0:?} price!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${LOG_DATE:?} Status() CoinMCap.API() Found ${G1:?}${API_VOLUME_CMC:?}${N0:?} volume!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${LOG_DATE:?} Status() CoinMCap.API() Found ${G1:?}${API_RANK_CMC:?}${N0:?} rank!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${LOG_DATE:?} Status() CoinMCap.API() Found ${G1:?}${API_WATCH_CMC:?}${N0:?} watchlist!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

  fi

  screen -X -S add_cmc quit &>/dev/null
  killall curl &>/dev/null
  rm "${LOG_DIR:?}"/node_data/requests* &>/dev/null
fi

### coingecko data #############################################################

# if success, create files, reset requests.cg file
if grep "success" "${LOG_DIR:?}"/node_data/requests.cg &>/dev/null; then

  # get token price
  grep -o -P '(?<=,).*(?=]],"m)' "${LOG_DIR:?}"/node_data/stats/raw.coingcko >"${LOG_DIR:?}"/node_data/stats/price.cg 2>&1
  # get token volume
  egrep -o "volumes.*" "${LOG_DIR:?}"/node_data/stats/raw.coingcko 2>&1 | tr -d '"|:' 2>&1 | awk -F, '{ print $2 }' 2>&1 | awk '{ printf "%.8f\n", $1 }' >"${LOG_DIR:?}"/node_data/stats/volume.cg 2>&1

  # coingecko api values
  API_PRICE_CG=$(cat "${LOG_DIR:?}"/node_data/stats/price.cg 2>/dev/null | awk '{ printf "%.4f\n", $1 }' 2>&1)
  API_VOLUME_CG=$(cat "${LOG_DIR:?}"/node_data/stats/volume.cg 2>/dev/null | awk '{ printf "%.2f\n", $1 }' 2>&1)
  if [[ -z "$API_PRICE_CG" ]] &>/dev/null; then
    API_PRICE_CG="0"
  fi
  if [[ -z "$API_VOLUME_CG" ]] &>/dev/null; then
    API_VOLUME_CG="0"
  fi

  # greater than n seconds, continue
  if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "420" ]] &>/dev/null; then

    printf '%b' "${GR:?}${LOG_DATE:?} Status() - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${LOG_DATE:?} Status() Coingcko.API() Found ${G1:?}${API_PRICE_CG:?}${N0:?} price!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${LOG_DATE:?} Status() Coingcko.API() Found ${G1:?}${API_VOLUME_CG:?}${N0:?} volume!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

  fi

  screen -X -S add_cg quit &>/dev/null
  killall curl &>/dev/null
  rm "${LOG_DIR:?}"/node_data/requests* &>/dev/null
fi

### wallet information #########################################################

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  # collect wallet info, on every minute (loop) from client
  "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/trumpcoin.conf getblockchaininfo 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/client/tmp/getblockchaininfo 2>&1
  "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/trumpcoin.conf getinfo 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/client/tmp/getinfo 2>&1
  "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/trumpcoin.conf getmempoolinfo 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/client/tmp/getmempoolinfo 2>&1
  "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/trumpcoin.conf getpatriotnodecount 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/client/tmp/getpatriotnodecount 2>&1
  "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/trumpcoin.conf getwalletinfo 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/client/tmp/getwalletinfo 2>&1
  "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/trumpcoin.conf listunspent 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/client/tmp/listunspent 2>&1
  "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/trumpcoin.conf getpeerinfo 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/client/tmp/getpeerinfo 2>&1
  "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/trumpcoin.conf listbanned 2>&1 | tr -d '"|,' >"${LOG_DIR:?}"/node_data/client/tmp/listbanned 2>&1
  # make sure data exist
  if grep -o "error: couldn't connect to server" "${LOG_DIR:?}"/node_data/client/tmp/getinfo &>/dev/null; then
    rm -R "${LOG_DIR:?}"/node_data/client/tmp/* &>/dev/null
  else # use existing data without any error(s)
    cp "${LOG_DIR:?}"/node_data/client/tmp/getblockchaininfo "${LOG_DIR:?}"/node_data/client/getblockchaininfo 2>&1
    cp "${LOG_DIR:?}"/node_data/client/tmp/getinfo "${LOG_DIR:?}"/node_data/client/getinfo 2>&1
    cp "${LOG_DIR:?}"/node_data/client/tmp/getmempoolinfo "${LOG_DIR:?}"/node_data/client/getmempoolinfo 2>&1
    cp "${LOG_DIR:?}"/node_data/client/tmp/getpatriotnodecount "${LOG_DIR:?}"/node_data/client/getpatriotnodecount 2>&1
    cp "${LOG_DIR:?}"/node_data/client/tmp/getwalletinfo "${LOG_DIR:?}"/node_data/client/getwalletinfo 2>&1
    cp "${LOG_DIR:?}"/node_data/client/tmp/listunspent "${LOG_DIR:?}"/node_data/client/listunspent 2>&1
    cp "${LOG_DIR:?}"/node_data/client/tmp/getpeerinfo "${LOG_DIR:?}"/node_data/client/getpeerinfo 2>&1
    cp "${LOG_DIR:?}"/node_data/client/tmp/listbanned "${LOG_DIR:?}"/node_data/client/listbanned 2>&1
  fi
fi

if [ ! -s "${LOG_DIR:?}"/node_data/stats/connections ] &>/dev/null; then
  # make sure connections exist
  echo "1" >"${LOG_DIR:?}"/node_data/stats/connections 2>&1
fi

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  # get wallet version, do this once
  if ! grep "v" "${LOG_DIR:?}"/node_data/client/version &>/dev/null; then
    "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/trumpcoin.conf -version 2>&1 | egrep -o "v[0-9]+.[0-9]+.[0-9]+.[0-9]+" >"${LOG_DIR:?}"/node_data/client/version 2>&1
  fi
  WALLET_VERSION=$(cat "${LOG_DIR:?}"/node_data/client/version 2>/dev/null)
fi

if [[ -z "$WALLET_VERSION" ]] &>/dev/null; then
  # wallet version, grey, waiting on daemon data
  WALLET_VERSION="${GR:?}vLoading${N0:?}"
fi

# running mainnet or testnet
if ! "$(grep "main" "${LOG_DIR:?}"/node_data/client/getblockchaininfo 2>&1)" -eq "main" &>/dev/null; then
  # mainnet
  WALLET_CHAIN="${G0:?}mainnet${N0:?}"
else # testnet
  WALLET_CHAIN="${C1:?}testnet${N0:?}"
fi

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -lt "300" ]] &>/dev/null; then

  # nonet
  WALLET_CHAIN="${CY:?}nonet${N0:?}"
fi

if [[ -f "${LOG_DIR:?}"/node_data/client/getblockchaininfo ]] &>/dev/null; then
  # get blockchain headers
  WALLET_HEADS=$(grep "blocks" "${LOG_DIR:?}"/node_data/client/getblockchaininfo 2>&1 | grep -Eo "[0-9]+" 2>&1)
  # get blockchain block
  WALLET_BLOCK=$(grep "headers" "${LOG_DIR:?}"/node_data/client/getblockchaininfo 2>&1 | grep -Eo "[0-9]+" 2>&1)
else
  WALLET_HEADS="${GR:?}0${N0:?}"
  WALLET_BLOCK="${GR:?}0${N0:?}"
fi

if ! grep -o "progress=1.000000" "${LOG_DIR:?}"/node_data/synced &>/dev/null; then
  # get blockchain sync
  WALLET_SYNC=$(cat "${LOG_DIR:?}"/node_data/client/tmp/proc 2>/dev/null | sed 's/^0*//' 2>&1 | tr -d '.' 2>&1)
  WALLET_SYNC=$(echo "100/999990*${WALLET_SYNC:?}" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
else
  # if progress equals 1, then 100% synced
  if [[ $(grep -o "progress=1.000000" "${LOG_DIR:?}"/node_data/synced 2>&1) ]] &>/dev/null; then
    WALLET_SYNC="100" # wallet blockchain is synced 100%
  fi
fi

if [[ -z "$WALLET_SYNC" ]] &>/dev/null; then
  WALLET_SYNC="${GR:?}0.00${N0:?}"
fi
if [[ -z "$WALLET_HEADS" ]] &>/dev/null; then
  WALLET_HEADS="${GR:?}0${N0:?}"
fi
if [[ -z "$WALLET_BLOCK" ]] &>/dev/null; then
  WALLET_BLOCK="${GR:?}0${N0:?}"
fi

# wallet sync (no color)
WALLET_SYNC_N="$WALLET_SYNC"
# wallet sync (color+symbol)
WALLET_SYNC="${G1:?}${WALLET_SYNC:?}%${N0:?}"

# wallet_nodes function (color)
function wallet_nodes() {
  WALLET_NODES_TOTAL="${GR:?}0${N0:?}"
  WALLET_NODES_STABLE="${GR:?}0${N0:?}"
  WALLET_NODES_ENABLED="${GR:?}0${N0:?}"
  WALLET_NODES_INQUEUE="${GR:?}0${N0:?}"
  WALLET_PEERS_LATEST="${GR:?}0${N0:?}"
  WALLET_PEERS_OTHER="${GR:?}0${N0:?}"
  WALLET_PEERS_TOTAL="${GR:?}0${N0:?}"
}

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  # get wallet patriotnodes total
  WALLET_NODES_TOTAL=$(grep "total" "${LOG_DIR:?}"/node_data/client/getpatriotnodecount 2>&1 |
    egrep -o "[0-9]+" 2>&1)
  # get wallet patriotnodes stable
  WALLET_NODES_STABLE=$(grep "stable" "${LOG_DIR:?}"/node_data/client/getpatriotnodecount 2>&1 |
    egrep -o "[0-9]+" 2>&1)
  # get wallet patriotnodes enabled
  WALLET_NODES_ENABLED=$(grep "enabled" "${LOG_DIR:?}"/node_data/client/getpatriotnodecount 2>&1 |
    egrep -o "[0-9]+" 2>&1)
  # get wallet patriotnodes inqueue
  WALLET_NODES_INQUEUE=$(grep "inqueue" "${LOG_DIR:?}"/node_data/client/getpatriotnodecount 2>&1 |
    egrep -o "[0-9]+" 2>&1)
  # count banned peers
  grep -c "address" "${LOG_DIR:?}"/node_data/client/listbanned >"${LOG_DIR:?}"/node_data/stats/bans 2>&1

  # get wallet connections (peers) total
  WALLET_PEERS_TOTAL=$(grep "connections" "${LOG_DIR:?}"/node_data/client/getinfo 2>&1 | awk '{ print $2 }' 2>&1)
  # wallet peers total (no color)
  WALLET_PEERS_TOTAL_N="$WALLET_PEERS_TOTAL"
  if [[ -z "$WALLET_PEERS_TOTAL_N" ]] &>/dev/null; then
    if [[ -f /home/"$(whoami)"/stats/peers.rrd ]] &>/dev/null; then
      # make sure peers exist, use rrdtool database, if available
      rrdtool info /home/"$(whoami)"/stats/peers.rrd 2>&1 | grep "last_ds" 2>&1 | awk '{ print $3 }' 2>&1 | tr -d '"' 2>&1 | awk '{ printf "%.0f\n", $1 }' >>"${LOG_DIR:?}"/node_data/stats/connections 2>&1
    fi
    # non responsive
    WALLET_PEERS_TOTAL_N=$(cat "${LOG_DIR:?}"/node_data/stats/connections 2>/dev/null | tail -1 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
  fi
  # create a list this time
  echo "$WALLET_PEERS_TOTAL_N" >>"${LOG_DIR:?}"/node_data/stats/connections

  # wallet peers total (color)
  WALLET_PEERS_TOTAL="${P1:?}$WALLET_PEERS_TOTAL${N0:?}"

  # get wallet connections latest (using wallet version)
  WALLET_PEERS_LATEST=$(grep "subver" "${LOG_DIR:?}"/node_data/client/getpeerinfo 2>&1 | egrep -o "$(echo "$WALLET_VERSION" 2>&1 | tr -d 'v' 2>&1)" 2>&1 | wc -l 2>&1)
  # get wallet connections other (not latest, probably older wallets)
  WALLET_PEERS_OTHER=$(grep "subver" "${LOG_DIR:?}"/node_data/client/getpeerinfo 2>&1 | egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1 | tr -d 'v' 2>&1 | grep -v "$(echo "$WALLET_VERSION" | tr -d 'v' 2>&1)" 2>&1 | wc -l 2>&1)

  # wallet peers latest (color)
  WALLET_PEERS_LATEST="${G1:?}${WALLET_PEERS_LATEST:?}${N0:?}"
  # wallet peers other (color)
  WALLET_PEERS_OTHER="${G0:?}${WALLET_PEERS_OTHER:?}${N0:?}"

# non responsive (no color)
elif [[ "$WALLET_PEERS_TOTAL_N" -eq "0" ]] &>/dev/null; then
  # non responsive
  wallet_nodes
elif [[ -z "$WALLET_PEERS_TOTAL_N" ]] &>/dev/null; then
  # non responsive
  wallet_nodes
else # non responsive
  wallet_nodes
fi

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  # get wallet balance
  WALLET_BALANCE=$(grep "balance" "${LOG_DIR:?}"/node_data/client/getinfo 2>&1 | egrep -o "[0-9]+.[0-9]+" 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
  # get unconfirmed balance
  WALLET_UNCONFIRMED=$(grep "unconfirmed_balance" "${LOG_DIR:?}"/node_data/client/getwalletinfo 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
  # get immature balance
  WALLET_IMMATURE=$(grep "immature_balance" "${LOG_DIR:?}"/node_data/client/getwalletinfo 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
  # get total balance, regardless of immature, unconfirmed values (combine them all)
  WALLET_BALANCE=$(echo "$WALLET_BALANCE+$WALLET_UNCONFIRMED+$WALLET_IMMATURE" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
  # save wallet value
  echo "${WALLET_BALANCE:?}" >"${LOG_DIR:?}"/node_data/stats/total_balance 2>&1

  # add direct price, volume (coingecko), disregard zeros, empty lines (no data)
  cat "${LOG_DIR:?}"/node_data/stats/price.cg 2>/dev/null | sed '/^$/d' 2>&1 | awk '{show=0; for (i=1; i<=NF; i++) {if ($i!=0) show=1; col[i]+=$i;}} show==1{tr++; for (i=1; i<=NF; i++) vals[tr,i]=$i; tc=NF} END{for(i=1; i<=tr; i++) { for (j=1; j<=tc; j++) { if (col[j]>0) printf("%s%s", vals[i,j], OFS)} print ""; } }' 2>&1 | awk '{ printf "%.4f\n", $1 }' >>"${LOG_DIR:?}"/node_data/stats/price.avg
  cat "${LOG_DIR:?}"/node_data/stats/volume.cg 2>/dev/null | sed '/^$/d' 2>&1 | awk '{show=0; for (i=1; i<=NF; i++) {if ($i!=0) show=1; col[i]+=$i;}} show==1{tr++; for (i=1; i<=NF; i++) vals[tr,i]=$i; tc=NF} END{for(i=1; i<=tr; i++) { for (j=1; j<=tc; j++) { if (col[j]>0) printf("%s%s", vals[i,j], OFS)} print ""; } }' 2>&1 | awk '{ printf "%.2f\n", $1 }' >>"${LOG_DIR:?}"/node_data/stats/volume.avg

  # add direct price, volume (coinmarketcap), disregard zeros, empty lines (no data)
  cat "${LOG_DIR:?}"/node_data/stats/price.cmc 2>/dev/null | sed '/^$/d' 2>&1 | awk '{show=0; for (i=1; i<=NF; i++) {if ($i!=0) show=1; col[i]+=$i;}} show==1{tr++; for (i=1; i<=NF; i++) vals[tr,i]=$i; tc=NF} END{for(i=1; i<=tr; i++) { for (j=1; j<=tc; j++) { if (col[j]>0) printf("%s%s", vals[i,j], OFS)} print ""; } }' 2>&1 | awk '{ printf "%.4f\n", $1 }' >>"${LOG_DIR:?}"/node_data/stats/price.avg
  cat "${LOG_DIR:?}"/node_data/stats/volume.cmc 2>/dev/null | sed '/^$/d' 2>&1 | awk '{show=0; for (i=1; i<=NF; i++) {if ($i!=0) show=1; col[i]+=$i;}} show==1{tr++; for (i=1; i<=NF; i++) vals[tr,i]=$i; tc=NF} END{for(i=1; i<=tr; i++) { for (j=1; j<=tc; j++) { if (col[j]>0) printf("%s%s", vals[i,j], OFS)} print ""; } }' 2>&1 | awk '{ printf "%.2f\n", $1 }' >>"${LOG_DIR:?}"/node_data/stats/volume.avg

  # create average ticker price and volume, disregard zeros, empty lines (no data)
  cat "${LOG_DIR:?}"/node_data/stats/price* 2>/dev/null | sed '/^$/d' 2>&1 | awk '{show=0; for (i=1; i<=NF; i++) {if ($i!=0) show=1; col[i]+=$i;}} show==1{tr++; for (i=1; i<=NF; i++) vals[tr,i]=$i; tc=NF} END{for(i=1; i<=tr; i++) { for (j=1; j<=tc; j++) { if (col[j]>0) printf("%s%s", vals[i,j], OFS)} print ""; } }' 2>&1 | xargs 2>&1 | awk '{ printf "%.8f\n", $1 }' >>"${LOG_DIR:?}"/node_data/stats/price.avg
  cat "${LOG_DIR:?}"/node_data/stats/volume* 2>/dev/null | sed '/^$/d' 2>&1 | awk '{show=0; for (i=1; i<=NF; i++) {if ($i!=0) show=1; col[i]+=$i;}} show==1{tr++; for (i=1; i<=NF; i++) vals[tr,i]=$i; tc=NF} END{for(i=1; i<=tr; i++) { for (j=1; j<=tc; j++) { if (col[j]>0) printf("%s%s", vals[i,j], OFS)} print ""; } }' 2>&1 | xargs 2>&1 | awk '{ printf "%.8f\n", $1 }' >>"${LOG_DIR:?}"/node_data/stats/volume.avg

  # count price and volume lines
  TICKER_COUNT=$(wc -l "${LOG_DIR:?}"/node_data/stats/price.avg 2>&1 | awk '{ print $1 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
  VOLUME_COUNT=$(wc -l "${LOG_DIR:?}"/node_data/stats/volume.avg 2>&1 | awk '{ print $1 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)

  # calculate average price and volume
  echo "$(awk '{ SUM += $1} END { print SUM }' "${LOG_DIR:?}"/node_data/stats/price.avg 2>&1)/${TICKER_COUNT:?}" 2>&1 | bc -l 2>&1 | awk '{ printf "%.8f\n", $1 }' >"${LOG_DIR:?}"/node_data/stats/price 2>&1
  echo "$(awk '{ SUM += $1} END { print SUM }' "${LOG_DIR:?}"/node_data/stats/volume.avg 2>&1)/${VOLUME_COUNT:?}" 2>&1 | bc -l 2>&1 | awk '{ printf "%.8f\n", $1 }' >"${LOG_DIR:?}"/node_data/stats/volume 2>&1

  if [[ "$(wc -l "${LOG_DIR:?}"/node_data/stats/price.avg 2>&1 | awk '{ print $1 }' 2>&1)" -gt "50" ]] &>/dev/null; then
    # keep last n of ticker price and volume, disregard zeros, empty lines (no data)
    echo "$(tail -25 "${LOG_DIR:?}"/node_data/stats/price.avg)" >"${LOG_DIR:?}"/node_data/stats/price.avg.tmp 2>&1
    cat "${LOG_DIR:?}"/node_data/stats/price.avg.tmp 2>/dev/null | sed '/^$/d' 2>&1 | awk '{show=0; for (i=1; i<=NF; i++) {if ($i!=0) show=1; col[i]+=$i;}} show==1{tr++; for (i=1; i<=NF; i++) vals[tr,i]=$i; tc=NF} END{for(i=1; i<=tr; i++) { for (j=1; j<=tc; j++) { if (col[j]>0) printf("%s%s", vals[i,j], OFS)} print ""; } }' 2>&1 | awk '{ printf "%.8f\n", $1 }' >"${LOG_DIR:?}"/node_data/stats/price.avg 2>&1
    echo "$(tail -25 "${LOG_DIR:?}"/node_data/stats/volume.avg)" >"${LOG_DIR:?}"/node_data/stats/volume.avg.tmp 2>&1
    cat "${LOG_DIR:?}"/node_data/stats/volume.avg.tmp 2>/dev/null | sed '/^$/d' 2>&1 | awk '{show=0; for (i=1; i<=NF; i++) {if ($i!=0) show=1; col[i]+=$i;}} show==1{tr++; for (i=1; i<=NF; i++) vals[tr,i]=$i; tc=NF} END{for(i=1; i<=tr; i++) { for (j=1; j<=tc; j++) { if (col[j]>0) printf("%s%s", vals[i,j], OFS)} print ""; } }' 2>&1 | awk '{ printf "%.8f\n", $1 }' >"${LOG_DIR:?}"/node_data/stats/volume.avg 2>&1
    # remove old files
    rm "${LOG_DIR:?}"/node_data/stats/*.*.tmp &>/dev/null
  fi

  # get wallet value
  WALLET_VALUE=$(echo "$(tail -1 "${LOG_DIR:?}"/node_data/stats/price 2>&1 | awk '{ printf "%.8f\n", $1 }' 2>&1)*$WALLET_BALANCE" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1 | tail -1 2>&1)

  # save balance valued value
  echo "${WALLET_VALUE:?}" >"${LOG_DIR:?}"/node_data/stats/balance_value 2>&1

  if [[ ! -f "${LOG_DIR:?}"/node_data/stats/volume ]] &>/dev/null; then
    if [[ -f /home/"$(whoami)"/stats/volume.rrd ]] &>/dev/null; then

      # make sure volume exist, use rrdtool database, if available
      rrdtool info /home/"$(whoami)"/stats/volume.rrd 2>&1 | grep "last_ds" 2>&1 | awk '{ print $1 }' 2>&1 | awk '{ printf "%.2f\n", $1 }' >"${LOG_DIR:?}"/node_data/stats/volume 2>&1
    fi
    WALLET_VALUE=$(cat "${LOG_DIR:?}"/node_data/stats/volume 2>/dev/null | awk '{ printf "%.2f\n", $1 }')
  fi

else # non responsive (color)
  WALLET_VALUE="${GR:?}0.00${N0:?}"
  WALLET_BALANCE="${GR:?}0.00${N0:?}"
  WALLET_IMMATURE="${GR:?}0.00${N0:?}"
  WALLET_UNCONFIRMED="${GR:?}0.00${N0:?}"
fi

# wallet_balances function (color)
function wallet_balances() {
  WALLET_TICKER="${GR:?}0${N0:?}"
  WALLET_MEMPOOL="${GR:?}0${N0:?}"
  WALLET_TXCOUNT="${GR:?}0${N0:?}"
  WALLET_INPUTS="${GR:?}0${N0:?}"
}

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  # get api price
  WALLET_TICKER=$(cat "${LOG_DIR:?}"/node_data/stats/price 2>/dev/null | tail -1 2>&1 | awk '{ printf "%.4f\n", $1 }' 2>&1)
  # get wallet mempool
  WALLET_MEMPOOL=$(grep "size" "${LOG_DIR:?}"/node_data/client/getmempoolinfo 2>&1 | egrep -o "[0-9]+" 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
  # get wallet txcount
  WALLET_TXCOUNT=$(grep "txcount" "${LOG_DIR:?}"/node_data/client/getwalletinfo 2>&1 | egrep -o "[0-9]+" 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
  # get wallet inputs
  WALLET_INPUTS=$(grep "address" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | wc -l 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
fi

# only zeros
if [[ "$WALLET_TXCOUNT" -eq "0" ]] &>/dev/null; then
  # non responsive
  wallet_balances
fi
if [[ -z "$WALLET_TXCOUNT" ]] &>/dev/null; then
  # non responsive
  wallet_balances
fi

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "1" ]] &>/dev/null; then

  if [ ! -f "${LOG_DIR:?}"/node_data/client/listunspent ] &>/dev/null; then
    # make sure listunspent exist
    touch "${LOG_DIR:?}"/node_data/client/listunspent &>/dev/null
  fi
  if [ ! -f "${LOG_DIR:?}"/node_data/add_peers ] &>/dev/null; then
    # make sure add_peers exist
    touch "${LOG_DIR:?}"/node_data/add_peers &>/dev/null
  fi

  # get last confirmation (smallest one)
  LAST_TX=$(grep "confirmations" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | sort -n 2>&1 | head -1 2>&1)
  # get last wallet txid with help of last_tx var
  WALLET_TXLAST=$(cat "${LOG_DIR:?}"/node_data/client/listunspent 2>/dev/null | tr -d ':' 2>&1 | grep -B8 "confirmations $LAST_TX" 2>&1 | grep "txid" 2>&1 | awk '{ print $2 }' 2>&1 | tail -1 2>&1)

  if ! grep -o "progress=1.000000" "${LOG_DIR:?}"/node_data/synced &>/dev/null; then
    # look for 'progress=1' line, save it there and then
    grep "progress=1.000000" "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | tail -1 >"${LOG_DIR:?}"/node_data/synced 2>&1
  fi
fi

TX="${GR:?}"

# wallet sync
if [[ "$(tail -100 "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | grep "skipped on sync" 2>&1)" ]] &>/dev/null; then
  # remove old synced value
  rm "${LOG_DIR:?}"/node_data/synced &>/dev/null
fi

if ! grep -o "progress=1.000000" "${LOG_DIR:?}"/node_data/synced &>/dev/null; then

  # get blockchain sync progress
  source /usr/local/bin/include/proc

  TX="${G1:?}" # sync bar color
  # replace wallet_txlast with sync_progress_bar
  WALLET_TXLAST="${SYNC_PROGRESS_BAR:?}"
fi

if [[ -z "$SYNC_PROGRESS_BAR" ]] &>/dev/null; then
  # non responsive
  SYNC_PROGRESS_BAR="${GR:?}$(tr -dc 'a-z' </dev/urandom 2>&1 | head -c 64 2>&1 | rev 2>&1)${N0:?}"
fi

if [[ -z "$WALLET_TXLAST" ]] &>/dev/null; then
  # non responsive
  WALLET_TXLAST="${GR:?}$(tr -dc 'a-z' </dev/urandom 2>&1 | head -c 64 2>&1 | rev 2>&1)${N0:?}"
fi

# if synced is still empty
if ! grep -o "progress=1.000000" "${LOG_DIR:?}"/node_data/synced &>/dev/null; then
  # look for sync line, save it there and then
  grep "progress=1.000000" "${WALLET_LOG_DIR:?}"/debug.log >"${LOG_DIR:?}"/node_data/synced 2>&1
fi

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  # save wallet stakes (addtowallet), remove duplicates

  if [ ! -f "${WALLET_DIR:?}"/staking ] &>/dev/null; then
    # make sure staking exist
    touch "${WALLET_DIR:?}"/staking &>/dev/null
  fi

  # get wallet stakes count
  grep -c "BitcoinMiner : proof-of-stake block was signed" "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/node_data/stats/staking 2>&1
  # get wallet proof-of-stake value
  WALLET_POS=$(cat "${LOG_DIR:?}"/node_data/stats/staking 2>/dev/null | awk '{ printf "%.0f\n", $1 }' 2>&1)
  # count saved vs wallet stakes
  SAVED_POS=$(wc -l "${WALLET_DIR:?}"/staking 2>&1 | awk '{ print $1 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
  if [[ -z "$WALLET_POS" ]] &>/dev/null; then
    # non responsive
    WALLET_POS="0"
  fi
  WALLET_STAKES="${WALLET_POS:?}"
  # wallet pos value greater then saved pos value
  if [[ "$WALLET_POS" -gt "$SAVED_POS" ]] &>/dev/null; then
    # get bitcoinminer, remove duplicates
    grep "BitcoinMiner : proof-of-stake block was signed" "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | awk '!a[$0]++' >"${WALLET_DIR:?}"/staking 2>&1
    printf '%b' "${LOG_DATE:?} Status() Proof.Of.Stake Saved ${G1:?}${WALLET_POS:?}${GR:?} :: ${N0:?}proof-of-stake data!${GR:?} :: ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
else # non responsive (color)
  WALLET_STAKES="${GR:?}0${N0:?}"
fi

# wallet_dashbord function (color)
function wallet_dashbord() {
  POS_STATUS="${GR:?}S${N0:?}"
  WALLET_BALANCE="${GR:?}${WALLET_BALANCE:?}${N0:?}"
  WALLET_STAKES="${GR:?}${WALLET_STAKES:?}${N0:?}"
  WALLET_INPUTS="${GR:?}${WALLET_INPUTS:?}${N0:?}"
}

if [ -f "${LOG_DIR:?}"/node_data/client/getinfo ] &>/dev/null; then
  # wallet pos status
  if [[ "$(grep "Staking Active" "${LOG_DIR:?}"/node_data/client/getinfo 2>&1)" ]] &>/dev/null; then
    # pos active
    POS_STATUS="${G1:?}S${N0:?}"
    # balance is staking, highlight balance, stakes and inputs (color)
    WALLET_BALANCE="${G1:?}${WALLET_BALANCE:?}${N0:?}"
    WALLET_STAKES="${G1:?}${WALLET_STAKES:?}${N0:?}"
    WALLET_INPUTS="${G1:?}${WALLET_INPUTS:?}${N0:?}"
  else # pos not active (color) waiting on daemon data
    wallet_dashbord
  fi
else
  wallet_dashbord
fi

# get blockchain activity with mempool
if [[ "$WALLET_MEMPOOL" -gt "0" ]] &>/dev/null; then
  # save activity values (1) to mempool.activity
  echo "1" >>"${LOG_DIR:?}"/node_data/stats/mempool 2>&1
else # save no activity values (0) to mempool.activity
  echo "0" >>"${LOG_DIR:?}"/node_data/stats/mempool 2>&1
fi

# reset mempool after 1440 lines (1440min=1day)
if [[ "$(wc -l "${LOG_DIR:?}"/node_data/stats/mempool 2>&1 | awk '{ print $1 }' 2>&1)" -gt "1440" ]] &>/dev/null; then
  # keep log at 720 lines (12h)
  echo "$(tail -720 "${LOG_DIR:?}"/node_data/stats/mempool 2>&1)" >"${LOG_DIR:?}"/node_data/stats/mempool 2>&1
fi

# reset connections after 1440 lines (1440min=1day)
if [[ "$(wc -l "${LOG_DIR:?}"/node_data/stats/connections 2>&1 | awk '{ print $1 }' 2>&1)" -gt "1440" ]] &>/dev/null; then
  # keep log at 720 lines (12h)
  echo "$(tail -720 "${LOG_DIR:?}"/node_data/stats/connections 2>&1)" >"${LOG_DIR:?}"/node_data/stats/connections 2>&1
fi

# get difficulty and save values to difficulty
grep "difficulty" "${LOG_DIR:?}"/node_data/client/getinfo 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1 | egrep "[1-9]+" >>"${LOG_DIR:?}"/node_data/stats/difficulty

# reset difficulty after 1440 lines (1440min=1day)
if [[ "$(wc -l "${LOG_DIR:?}"/node_data/stats/difficulty 2>&1 | awk '{ print $1 }' 2>&1)" -gt "1440" ]] &>/dev/null; then
  # keep log at 720 lines (12h)
  echo "$(tail -720 "${LOG_DIR:?}"/node_data/stats/difficulty 2>&1)" >"${LOG_DIR:?}"/node_data/stats/difficulty 2>&1
fi

### adding nodes, create failed and success lists ##############################

if [ ! -f "${WALLET_DIR:?}"/addnodes ] &>/dev/null; then
  # make sure addnodes file exist
  touch "${WALLET_DIR:?}"/addnodes &>/dev/null
fi
if [ ! -f "${LOG_DIR:?}"/node_data/peers.tmp ] &>/dev/null; then
  # make sure peers.tmp file exist
  touch "${LOG_DIR:?}"/node_data/peers.tmp &>/dev/null
fi

# always run if uptime is less than n seconds
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -lt "3600" ]] &>/dev/null; then
  FAILED_CHECK=$(echo "${LOG_CHECK:?}" 2>&1)
else
  FAILED_CHECK="[0-9]+:[0-9]+0:[0-9]+" # **:*0:**
fi

ADDNODES_CHECK="[0-9]+:[0-9]+0:[0-9]+"            # **:*0:**
DATA_CHECK="[0-9]+:30:[0-9]+|[0-9]+:00:[0-9]+"    # **:30:** | **:00:**
ADD_P2P_CHECK="[0-9]+:30:[0-9]+|[0-9]+:00:[0-9]+" # **:30:** | **:00:** !
# run with set time schedule (! means reverse)

### personal addnodes ##########################################################

# run data with intervals, every n minutes
if [[ "$(echo "${LOG_CHECK:?}" 2>&1 | egrep "${ADDNODES_CHECK:?}" 2>&1)" ]] &>/dev/null; then
  # add addnodes backup if backup is greater
  if [[ "$(wc -l "${WALLET_DIR:?}"/addnodes 2>&1 | awk '{ print $1 }' 2>&1)" -gt "$(wc -l "${LOG_DIR:?}"/node_data/peers/success 2>&1 | awk '{ print $1 }' 2>&1)" ]] &>/dev/null; then
    cp "${WALLET_DIR:?}"/addnodes "${LOG_DIR:?}"/node_data/peers.tmp 2>&1
    printf '%b' "${LOG_DATE:?} Status() Addnode.Script Adding backup peers! $(wc -l "${WALLET_DIR:?}"/addnodes 2>&1 | awk '{ print $1 }' 2>&1) ${C1:?}>>${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    # clear out failed connections (old peers, different ports)
    grep -vf "${LOG_DIR:?}"/node_data/peers/failed "${WALLET_DIR:?}"/addnodes 2>&1 | awk -F: '{ print $1 }' 2>&1 | awk '!a[$0]++' >"${WALLET_DIR:?}"/addnodes.tmp 2>&1
    mv "${WALLET_DIR:?}"/addnodes.tmp "${WALLET_DIR:?}"/addnodes 2>&1
  fi
fi

# run data with intervals, every n minutes
if [[ "$(echo "${LOG_CHECK:?}" 2>&1 | egrep "${ADDNODES_CHECK:?}" 2>&1)" ]] &>/dev/null; then
  # create addnodes backup if backup is less
  if [[ "$(wc -l "${WALLET_DIR:?}"/addnodes 2>&1 | awk '{ print $1 }' 2>&1)" -lt "$(wc -l "${LOG_DIR:?}"/node_data/peers/success 2>&1 | awk '{ print $1 }' 2>&1)" ]] &>/dev/null; then
    cp "${LOG_DIR:?}"/node_data/peers/success "${WALLET_DIR:?}"/addnodes 2>&1
    printf '%b' "${LOG_DATE:?} Status() Addnode.Script Creating addnodes backup! $(wc -l "${LOG_DIR:?}"/node_data/peers/success 2>&1 | awk '{ print $1 }' 2>&1) ${C1:?}<<${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

# make sure addnodes exist
touch /home/"$(whoami)"/addnodes &>/dev/null

# use personal addnodes if any data
if [[ "$(wc -l /home/"$(whoami)"/addnodes 2>&1 | awk '{ print $1 }' 2>&1)" -gt "0" ]] &>/dev/null; then

  # get clean ipv4 address, disregard non ipv4
  egrep -o '([0-9]{1,3}\.){3}[0-9]{1,3}' /home/"$(whoami)"/addnodes >"${LOG_DIR:?}"/addnodes.ipv4 2>&1
  # get clean ipv6 address, disregard non ipv6 and lines shorter than n
  egrep -o '([A-Fa-f0-9]{1,4}::?){1,7}[A-Fa-f0-9]{1,4}' /home/"$(whoami)"/addnodes 2>&1 | sed -r '/^.{,8}$/d' >"${LOG_DIR:?}"/addnodes.ipv6 2>&1
  # get clean dns address, disregard non dns
  grep -oiE '([a-zA-Z0-9][a-zA-Z0-9-]{1,61}\.){1,}(\.?[a-zA-Z]{2,}){1,}' /home/"$(whoami)"/addnodes >"${LOG_DIR:?}"/addnodes.dns 2>&1

  # add extra(s), disregard invalid pattern address (cidr - classless inter-domain routing)
  grepcidr -f "${LOG_DIR:?}"/addnodes.ipv4 "${LOG_DIR:?}"/addnodes.ipv4 >"${LOG_DIR:?}"/node_data/peers.x 2>"${LOG_DIR:?}"/node_data/peers.cidr
  grepcidr -f "${LOG_DIR:?}"/addnodes.ipv6 "${LOG_DIR:?}"/addnodes.ipv6 >>"${LOG_DIR:?}"/node_data/peers.x 2>"${LOG_DIR:?}"/node_data/peers.cidr
  # add extra(s) domain names
  cat "${LOG_DIR:?}"/addnodes.dns >>"${LOG_DIR:?}"/node_data/peers.x 2>/dev/null

  printf '%b' "${LOG_DATE:?} Status() Addnode.Script Adding extra nodes\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  printf '%b' "${LOG_DATE:?} Status() Addnode.Script |_IPv4 $(wc -l "${LOG_DIR:?}"/addnodes.ipv4 2>&1 | awk '{ print $1 }' 2>&1)\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  printf '%b' "${LOG_DATE:?} Status() Addnode.Script |_IPv6 $(wc -l "${LOG_DIR:?}"/addnodes.ipv6 2>&1 | awk '{ print $1 }' 2>&1)\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  printf '%b' "${LOG_DATE:?} Status() Addnode.Script |_DNS+ $(wc -l "${LOG_DIR:?}"/addnodes.dns 2>&1 | awk '{ print $1 }' 2>&1)\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  printf '%b' "${LOG_DATE:?} Status() Addnode.Script | ${G1:?}$(echo "$(wc -l "${LOG_DIR:?}"/addnodes.ipv4 2>&1 | awk '{ print $1 }' 2>&1)+$(wc -l "${LOG_DIR:?}"/addnodes.ipv6 2>&1 | awk '{ print $1 }' 2>&1)+$(wc -l "${LOG_DIR:?}"/addnodes.dns 2>&1 | awk '{ print $1 }' 2>&1)" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1) Total ${CY:?}>>${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

  # truncate/remove file(s), now old
  truncate -s 0 /home/"$(whoami)"/addnodes &>/dev/null
  rm "${LOG_DIR:?}"/addnodes.ipv4 &>/dev/null
  rm "${LOG_DIR:?}"/addnodes.ipv6 &>/dev/null
  rm "${LOG_DIR:?}"/addnodes.dns &>/dev/null
fi

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  # run data with intervals, every n minutes, update api, arp and ticker
  if [[ "$(echo "${LOG_CHECK:?}" 2>&1 | egrep "${DATA_CHECK:?}" 2>&1)" ]] &>/dev/null; then
    # run data
    source /usr/local/bin/include/data
  fi
fi

### failed and success lists ###################################################

if [ ! -f "${LOG_DIR:?}"/node_data/peers/failed ] &>/dev/null; then
  # make sure failed exist
  touch "${LOG_DIR:?}"/node_data/peers/failed &>/dev/null
fi
if [ ! -f "${LOG_DIR:?}"/node_data/peers/success ] &>/dev/null; then
  # make sure success exist
  touch "${LOG_DIR:?}"/node_data/peers/success &>/dev/null
fi

# failed_peers function
function failed_peers() {
  egrep -o " to .* failed" "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | awk '{ print $2 }' 2>&1 | awk '!a[$0]++' 2>&1 | sed -r '/^.{,7}$/d' 2>&1 | sort -n 2>&1 | grep -v "addnode" >"${LOG_DIR:?}"/node_data/peers/failed 2>&1
  # add system ip address
  echo "$IP_ADDRESS_N" >>"${LOG_DIR:?}"/node_data/peers/failed 2>&1
  awk '!a[$0]++' "${LOG_DIR:?}"/node_data/peers/failed >"${LOG_DIR:?}"/node_data/peers/failed.clean 2>&1
  mv "${LOG_DIR:?}"/node_data/peers/failed.clean "${LOG_DIR:?}"/node_data/peers/failed 2>&1
  ONION_FAILS=$(egrep "[a0-z9]+.onion" "${LOG_DIR:?}"/node_data/peers/failed 2>&1 | wc -l 2>&1)
  IPV4_FAILS=$(egrep "[0-9]+.[0-9]+.[0-9]+.[0-9]+" "${LOG_DIR:?}"/node_data/peers/failed 2>&1 | grep -v ".onion" 2>&1 | wc -l 2>&1)
  DNS_FAILS=$(egrep ".[a-z]" "${LOG_DIR:?}"/node_data/peers/failed 2>&1 | grep -v ".onion" 2>&1 | wc -l 2>&1)
  # greater than n seconds, continue
  if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then
    printf '%b' "${LOG_DATE:?} Status() Addnode.Script Updating failed list! $(wc -l "${LOG_DIR:?}"/node_data/peers/failed 2>&1 | awk '{ print $1 }' 2>&1) ${G1:?}${IPV4_FAILS:?}${N0:?}/${CY:?}${DNS_FAILS:?}${N0:?}/${P0:?}${ONION_FAILS:?} ${GR:?}>>${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
}

if [[ "$(echo "${LOG_CHECK:?}" 2>&1 | egrep "${FAILED_CHECK:?}" 2>&1)" ]] &>/dev/null; then
  # failed_peers function
  failed_peers
  # disregard random ip address (ipv4)
  grep -vf "${LOG_DIR:?}"/node_data/peers.ipv4.r "${LOG_DIR:?}"/node_data/peers/failed 2>&1 | sort -n 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/node_data/peers/failed.tmp 2>&1
  mv "${LOG_DIR:?}"/node_data/peers/failed.tmp "${LOG_DIR:?}"/node_data/peers/failed 2>&1
fi

# create "connected/working" ipv4/ipv6 peers list, sort, remove duplicates
# note: only use addr, no port
if [ -f "${LOG_DIR:?}"/node_data/client/getpeerinfo ] &>/dev/null; then
  # get clean ipv4 address, disregard non ipv4
  egrep -o '([0-9]{1,3}\.){3}[0-9]{1,3}' "${LOG_DIR:?}"/node_data/client/getpeerinfo 2>&1 | sort -n 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/success 2>&1
  # get clean ipv6 address, disregard non ipv6 and lines shorter than n
  egrep -o '([A-Fa-f0-9]{1,4}::?){1,7}[A-Fa-f0-9]{1,4}' "${LOG_DIR:?}"/node_data/client/getpeerinfo 2>&1 | sort -n 2>&1 | awk '!a[$0]++' 2>&1 | sed -r '/^.{,8}$/d' >>"${LOG_DIR:?}"/success 2>&1
  # get clean dns address, disregard non dns
  grep -oiE '([a-zA-Z0-9][a-zA-Z0-9-]{1,61}\.){1,}(\.?[a-zA-Z]{2,}){1,}' "${LOG_DIR:?}"/node_data/client/getpeerinfo 2>&1 | sort -n 2>&1 | awk '!a[$0]++' >>"${LOG_DIR:?}"/success 2>&1
  # remove duplicates, sort, disregard 127 address
  cat "${LOG_DIR:?}"/success 2>/dev/null | awk '!a[$0]++' 2>&1 | sort -n 2>&1 | grep -v "127." >"${LOG_DIR:?}"/node_data/peers/success 2>&1
  # remove old file
  rm "${LOG_DIR:?}"/success &>/dev/null
fi

### add_peers screen script ####################################################

# create screen list
LC_ALL=de_US.utf8 screen -list >"${LOG_DIR:?}"/node_data/stats/screens 2>&1

# kill when too many screens appears (all of them)
if [[ "$(cat "${LOG_DIR:?}"/node_data/stats/screens 2>/dev/null | grep -c "add_peers")" -gt "1" ]] &>/dev/null; then
  killall screen &>/dev/null
fi

# kill dead screens
if cat "${LOG_DIR:?}"/node_data/stats/screens 2>/dev/null | grep "dead" &>/dev/null; then

  if cat "${LOG_DIR:?}"/node_data/stats/screens 2>/dev/null | grep -q "add_peers" &>/dev/null; then
    screen -wipe &>/dev/null
    screen -X -S add_peers quit &>/dev/null
    printf '%b' "${LOG_DATE:?} Status() Addnode.Script (add_peers) dead ??? it's dead now.${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
  if cat "${LOG_DIR:?}"/node_data/stats/screens 2>/dev/null | grep -q "add_cmc" &>/dev/null; then
    screen -wipe &>/dev/null
    screen -X -S add_cmc quit &>/dev/null
    killall curl &>/dev/null
    printf '%b' "${LOG_DATE:?} Status() Addnode.Script (add_cmc) dead ??? it's dead now.${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
  if cat "${LOG_DIR:?}"/node_data/stats/screens 2>/dev/null | grep -q "add_cg" &>/dev/null; then
    screen -wipe &>/dev/null
    screen -X -S add_cg quit &>/dev/null
    killall curl &>/dev/null
    printf '%b' "${LOG_DATE:?} Status() Addnode.Script (add_cg) dead ??? it's dead now.${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

# look for screen session, if not found, run this block
if ! cat "${LOG_DIR:?}"/node_data/stats/screens 2>/dev/null | grep -q "add_peers" &>/dev/null; then

  cat "${LOG_DIR:?}"/node_data/peers.tmp 2>/dev/null | awk '!a[$0]++' 2>&1 | sort -n >"${LOG_DIR:?}"/node_data/add_peers 2>&1
  # make sure addnodes is clean of successfully peers, as above as below
  grep -vf "${LOG_DIR:?}"/node_data/peers/success "${LOG_DIR:?}"/node_data/add_peers >"${LOG_DIR:?}"/node_data/add_peers.tmp 2>&1
  if [[ -f "${LOG_DIR:?}"/node_data/add_peers.tmp ]] &>/dev/null; then
    cp "${LOG_DIR:?}"/node_data/add_peers.tmp "${LOG_DIR:?}"/node_data/add_peers 2>&1
  fi

  # greater than n seconds, continue
  if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

    if [ ! -f "${LOG_DIR:?}"/node_data/peers/success ] &>/dev/null; then
      # make sure success exist
      touch "${LOG_DIR:?}"/node_data/peers/success 2>&1
    fi

    ### random address ##################################################### ###

    # generate random ip address (ipv4)
    RIP_IPV4=$(printf "%d.%d.%d.%d\n" "$((RANDOM % 256))" "$((RANDOM % 256))" "$((RANDOM % 256))" "$((RANDOM % 256))" 2>&1)
    # generate random ip address (ipv6)
    RIP_IPV6=$(for ((i = 0; i < 8; i++)); do printf "%02x%02x:" $((RANDOM % 256)) $((RANDOM % 256)); done 2>&1 | sed 's/:$//' 2>&1)
    # create address (ipv4/ipv6), ignore common default router ip address (ipv4)
    echo "$RIP_IPV6" >>"${LOG_DIR:?}"/node_data/peers.ipv6.r 2>&1
    echo "$RIP_IPV4" 2>&1 | grep -vwE "(${IP_ADDRESS_N:?}|127.0.0.1|192.168.1.1|192.168.0.1|192.168.1.10.1|192.168.2.1|192.168.1.254|192.168.0.30|192.168.0.50|10.0.0.2|10.1.1.1|10.0.1.1|10.0.0.1|10.0.0.138|10.10.1.1)" >>"${LOG_DIR:?}"/node_data/peers.ipv4.r 2>&1

    # move random address to add_peers (ipv4/ipv6)
    cat "${LOG_DIR:?}"/node_data/peers.ipv4.r 2>/dev/null | tail -1 >>"${LOG_DIR:?}"/node_data/add_peers
    cat "${LOG_DIR:?}"/node_data/peers.ipv6.r 2>/dev/null | tail -1 >>"${LOG_DIR:?}"/node_data/add_peers

    ### remove failed, connected peers and invalid pattern address ######### ###

    # disregard already connected peers (success list)
    grep -vf "${LOG_DIR:?}"/node_data/peers/success "${LOG_DIR:?}"/node_data/add_peers 2>&1 | sort -n >"${LOG_DIR:?}"/node_data/add_peers.tmp 2>&1
    if [[ -f "${LOG_DIR:?}"/node_data/add_peers.tmp ]] &>/dev/null; then
      cp "${LOG_DIR:?}"/node_data/add_peers.tmp "${LOG_DIR:?}"/node_data/add_peers 2>&1
    fi

    # disregard failed peers (failed list), remove 127. address (localhost)
    grep -vf "${LOG_DIR:?}"/node_data/peers/failed "${LOG_DIR:?}"/node_data/add_peers 2>&1 | sort -n 2>&1 | grep -v "127." >"${LOG_DIR:?}"/node_data/add_peers.tmp 2>&1
    if [[ -f "${LOG_DIR:?}"/node_data/add_peers.tmp ]] &>/dev/null; then
      cp "${LOG_DIR:?}"/node_data/add_peers.tmp "${LOG_DIR:?}"/node_data/add_peers 2>&1
    fi

    # disregard invalid pattern address (cidr - classless inter-domain routing) and count wrong patterns (cidr)
    grepcidr -f "${LOG_DIR:?}"/node_data/add_peers "${LOG_DIR:?}"/node_data/add_peers >"${LOG_DIR:?}"/node_data/add_peers.tmp 2>"${LOG_DIR:?}"/node_data/peers.cidr
    # disregard onion address
    grep -v ".onion" "${LOG_DIR:?}"/node_data/peers.cidr >"${LOG_DIR:?}"/node_data/peers.cidr.tmp 2>&1
    mv "${LOG_DIR:?}"/node_data/peers.cidr.tmp "${LOG_DIR:?}"/node_data/peers.cidr 2>&1
    # count all invalid patterns
    INV_CIDR=$(wc -l "${LOG_DIR:?}"/node_data/peers.cidr 2>&1 | tail -1 2>&1 | awk '{ print $1 }' 2>&1)
    if [[ -f "${LOG_DIR:?}"/node_data/add_peers.tmp ]] &>/dev/null; then
      cp "${LOG_DIR:?}"/node_data/add_peers.tmp "${LOG_DIR:?}"/node_data/add_peers 2>&1
    fi

    # create total cidr list
    cat "${LOG_DIR:?}"/node_data/peers.cidr >>"${LOG_DIR:?}"/node_data/stats/total.cidr 2>/dev/null
    # count total invalid patterns
    TOT_INV_CIDR=$(wc -l "${LOG_DIR:?}"/node_data/stats/total.cidr 2>&1 | tail -1 2>&1 | awk '{ print $1 }' 2>&1)

    printf '%b' "${LOG_DATE:?} Status() Addnode.Script ${INV_CIDR:?}/${TOT_INV_CIDR:?} Invalid pattern (CIDR) ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

    if [ -f "${LOG_DIR:?}"/node_data/peers.x ] &>/dev/null; then
      # add extras from personal addnodes
      cat "${LOG_DIR:?}"/node_data/peers.x >>"${LOG_DIR:?}"/node_data/add_peers 2>/dev/null
      # remove file, now old
      rm "${LOG_DIR:?}"/node_data/peers.x &>/dev/null
    fi

    # clean up cidr files
    truncate -s 0 "${LOG_DIR:?}"/node_data/peers.cidr &>/dev/null

    # create screen session
    screen -dmS add_peers 2>&1

    # create temp and backup list for connection check
    cp "${LOG_DIR:?}"/node_data/add_peers "${LOG_DIR:?}"/node_data/add_peers.check 2>&1

    # make sure add_peers exist
    if [ ! -f "${LOG_DIR:?}"/add_peers ] &>/dev/null; then
      # connect nodes found with nodes list above, (using tmp directory)
      cat >"${LOG_DIR:?}"/add_peers <<'EOF'
#!/bin/bash

# By Rainman
# V20221402
# 0.0.4.5

source /usr/local/bin/include/pinode.conf
source /usr/local/bin/include/color

WALLET_DAEMON="trumpcoind"
WALLET_CLIENT="trumpcoin-cli"

# date for logs
LOG_DATE=$(cat "${LOG_DIR:?}"/node_data/stats/date 2>/dev/null)

P2P=$(cat "${LOG_DIR:?}"/node_data/stats/connections 2>/dev/null | egrep "[0-9]+" 2>&1 | tail -1 2>&1)
P2P_OLD=$(cat "${LOG_DIR:?}"/node_data/stats/connections 2>/dev/null | egrep "[0-9]+" 2>&1 | tail -1 2>&1)
printf '%b' "${LOG_DATE:?} Status() Addnode.Script Starting adding nodes! +$(wc -l "${LOG_DIR:?}"/node_data/add_peers 2>&1 | awk '{ print $1 }' 2>&1) P2P ${P2P:?} ${G1:?}>${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

LC_ALL=de_US.utf8 screen -list >"${LOG_DIR:?}"/node_data/stats/screens 2>&1

while IFS= read -r ADDS; do
  "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/trumpcoin.conf addnode "$ADDS" onetry 2>&1
done <"${LOG_DIR:?}"/node_data/add_peers 2>&1 | shuf 2>&1 | grep -vf "${LOG_DIR:?}"/node_data/peers/success 2>&1

P2P=$(cat "${LOG_DIR:?}"/node_data/stats/connections 2>/dev/null | egrep "[0-9]+" 2>&1 | tail -1 2>&1)
FAILED=$(grep " to $(cat "${LOG_DIR:?}"/node_data/add_peers.check 2>/dev/null) failed" "$WALLET_LOG_DIR"/debug.log 2>&1 | egrep -o " to .*. failed" 2>&1 | awk '!a[$0]++' 2>&1 | wc -l 2>&1)

P2P_NEW=$(grep "Stopping adding nodes" "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | tail -1 2>&1 | egrep -o "P2P [0-9]+" 2>&1 | awk '{ print $2 }' 2>&1)
P2P_CHANGE=$(echo "$P2P_NEW-$P2P_OLD" 2>&1 | bc -l 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)

if [[ "$P2P_CHANGE" -gt "0" ]] &>/dev/null; then
  P2PC="${G1:?}+"
else
  P2PC="${R1:?}"
fi
if [[ "$P2P_CHANGE" -eq "0" ]] &>/dev/null; then
  P2PC="${GR:?}"
fi

printf '%b' "${LOG_DATE:?} Status() Addnode.Script Stopping adding nodes! ${GR:?}-$FAILED${N0:?} P2P ${P2P:?} ${GR:?}<${N0:?} ${P2PC:?}${P2P_CHANGE:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

screen -X -S add_peers quit &>/dev/null
LC_ALL=de_US.utf8 screen -list >"${LOG_DIR:?}"/node_data/stats/screens 2>&1
exit
EOF
    fi

    # don't run script with intervals, every n minutes, updating api, arp and ticker (updating lists)
    if [[ ! "$(echo "${LOG_CHECK:?}" 2>&1 | egrep "${ADD_P2P_CHECK:?}" 2>&1)" ]] &>/dev/null; then

      # 60s 90s 120s 240s 300s 600s, 900s, 1800s = 30 minutes
      # start adding nodes, inside screen session (timeout n seconds)
      timeout 1800 screen -S add_peers -X -p 0 stuff $'bash '"${LOG_DIR:?}"'/add_peers\n'
    else
      screen -X -S add_peers quit &>/dev/null
      printf '%b' "${LOG_DATE:?} Status() Addnode.Script skipping add_peers script.${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    fi
  fi
fi

### restore proof-of-stake data ################################################

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  # save proof-of-stake data from debug.log
  # count saved vs wallet stakes
  SAVED_POS=$(wc -l "${WALLET_DIR:?}"/staking 2>&1 | awk '{ print $1 }' 2>&1)
  # get wallet proof-of-stake value
  WALLET_POS=$(cat "${LOG_DIR:?}"/node_data/stats/staking 2>/dev/null)
  # if wallet pos is less than saved pos
  if [[ "$WALLET_POS" -lt "$SAVED_POS" ]] &>/dev/null; then
    # restore missing proof-of-stake data
    cat "${WALLET_DIR:?}"/staking 2>/dev/null | awk '!a[$0]++' >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${LOG_DATE:?} Status() Proof.Of.Stake Restored PoS Data! - ${G1:?}${SAVED_POS:?}${GR:?} :: ${N0:?}proof-of-stake data!${GR:?} :: ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

### backup, clean up lists, logs (truncate) keep proof-of-stake data ###########

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  # note: heavy reading, do interval reading with date:time
  if [[ "$(LC_ALL=de_US.utf8 date '+%H%M' 2>&1 | grep -Eo "0000" 2>&1)" ]] &>/dev/null; then

    # remove, reset old files, locks, backups ruled by configuration

    # remove wallet backups, ruled by configuration
    if [[ "$KEEP_BACKUPS" -eq "0" ]] &>/dev/null; then
      rm -r "${WALLET_DIR:?}"/backups/* &>/dev/null
      printf '%b' "${LOG_DATE:?} Status() Clean.remove() Deleting wallet backups${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    fi

    # update repository, ruled by configuration
    if [[ "$UPDATE_REPO" -eq "1" ]] &>/dev/null; then
      # update repo, if set
      cd /home/"$(whoami)"/pi-node || exit &&
        git pull -q && bash include/install 2>&1
    fi

    DIS_LOCAL=$(echo "$(cat "${LOG_DIR:?}"/node_data/stats/ip_address 2>/dev/null)" 2>&1 | egrep -o "[0-9]+" 2>&1 | head -1 2>&1)
    # keep last n of failed connections
    RANDOM_FAILED=$((((RANDOM % 512) + 256)))
    echo "$(tail -"${RANDOM_FAILED:?}" "${LOG_DIR:?}"/node_data/peers/failed 2>&1 | grep -v "${DIS_LOCAL:?}" 2>&1)" 2>&1 | awk '!a[$0]++' >"${WALLET_DIR:?}"/failed 2>&1

    # repository latest head
    LATEST_HEAD=$(cd /home/"$(whoami)"/pi-node || exit && git rev-parse --short HEAD 2>&1 | grep -Eo '[a0-z9]{7}' 2>&1 | head -1 2>&1)
    # repository latest date
    LATEST_DATE=$(cd /home/"$(whoami)"/pi-node || exit && git log -1 --format="%at" | xargs -I{} date -d @{} '+%Y/%m/%d')
    # repository latest time
    LATEST_TIME=$(cd /home/"$(whoami)"/pi-node || exit && git log -1 --format="%at" | xargs -I{} date -d @{} '+%H:%M:%S')

    # count all new outbound peers inside debug.log
    P2P_SUCCESS=$(grep -c "New outbound peer" "${WALLET_LOG_DIR:?}"/debug.log 2>&1)
    # count all peers inside failed
    P2P_FAILED=$(wc -l "${LOG_DIR:?}"/node_data/peers/failed 2>&1 | awk '{ print $1 }' 2>&1)
    # calculate p2p success rate
    P2P_RATE=$(echo "100/$P2P_FAILED*$P2P_SUCCESS" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
    P2P_RATE="${CY:?}${P2P_RATE:?}%${N0:?}"

    # get nodes values
    ADD_PEERS_SIZE=$(wc -l "${LOG_DIR:?}"/node_data/nodes.all 2>&1 | awk '{ print $1 }' 2>&1)
    ADDNODES_ARP_SIZE=$(wc -l "${LOG_DIR:?}"/node_data/nodes.arp 2>&1 | awk '{ print $1 }' 2>&1)
    ADDNODES_CURL_SIZE=$(wc -l "${LOG_DIR:?}"/node_data/nodes.api 2>&1 | awk '{ print $1 }' 2>&1)
    ADDNODES_MANUAL_SIZE=$(wc -l /home/"$(whoami)"/addnodes 2>&1 | awk '{ print $1 }' 2>&1)

    # calculate average proof-of-stake time
    UNSPENT_COUNT=$(grep -c "confirmations" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
    TOTAL_TX=$(grep "confirmations" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ SUM += $1} END { print SUM }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
    # average calculated
    AVG_TX=$(echo "$TOTAL_TX/$UNSPENT_COUNT" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
    # calculate seconds
    SECONDS_TX=$(echo "$AVG_TX*60" 2>&1 | bc -l 2>&1 | awk -F. '{ print $1 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
    # calculate seconds into age
    INPUT_AGE=$(printf '%dh:%dm' $(("$SECONDS_TX/3600")) $(("$SECONDS_TX%3600/60")))
    # save the value
    echo "${INPUT_AGE:?}" >"${LOG_DIR:?}"/node_data/stats/avgconfirmation
    INPUT_AGE_D=$(echo "$(echo "$INPUT_AGE" 2>&1 | egrep -o "[0-9]+h" 2>&1 | tr -d 'h' 2>&1)/24" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
    AVG_POS_TIME="Average Time $AVG_TX (${INPUT_AGE_D:?}d) ${GR:?}$INPUT_AGE${N0:?}"

    SAVED_POS=$(wc -l "${WALLET_DIR:?}"/staking 2>&1 | awk '{ print $1 }' 2>&1)

    # interval dashbord for debug.log
    # note: should always start later on since daemon start (uptime_daemon)
    printf '%b' "${GR:?}${LOG_DATE:?} Status() - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    echo
    printf '%b' "${GR:?}${LOG_DATE:?} Status() SystemTorNet()${N0:?} Onion $(egrep -o "[a0-z9]+.onion" "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | tail -1 2>&1)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() SystemInternet${N0:?} WanIP $(grep "address" "${WALLET_DIR:?}"/getwan 2>&1 | egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() SystemIntranet${N0:?} Local ${IP_ADDRESS_N:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() Script.version${N0:?} Repository [${G1:?}${LATEST_HEAD:?}${N0:?}] ${GR:?}${LATEST_DATE:?}${N0:?} ${LATEST_TIME:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() System.Monitor${N0:?} Load ${LOAD:?} - temp ${CPU_CTEMP:?}C ${CPU_FTEMP:?}F ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() System.Monitor${N0:?} Free Mem ${FREE_MEM:?}/${TOTAL_MEM:?} - HDDuse ${USED_HDD:?} (${USED_HDD_P:?})${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() Fail/success()${N0:?} Fail ${R1:?}$P2P_FAILED${N0:?} Success ${G1:?}$P2P_SUCCESS${N0:?} Success Rate ${P2P_RATE:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() Addnode.Size()${N0:?} Add New Peers ${CY:?}${ADD_PEERS_SIZE:?}${N0:?} Addnode Peers ${C1:?}$ADDNODES_MANUAL_SIZE${N0:?} Arp ${G0:?}${ADDNODES_ARP_SIZE:?}${N0:?} Curl ${G1:?}${ADDNODES_CURL_SIZE:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() Peers.Status()${N0:?} Total ${WALLET_PEERS_TOTAL:?} Latest ${WALLET_PEERS_LATEST:?} Older ${WALLET_PEERS_OTHER:?} - ${G1:?}${N0:?} ${DOWNLOAD:?} ${R1:?}${N0:?} ${UPLOAD:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    printf '%b' "${GR:?}${LOG_DATE:?} Status() Proof.Of.Work:${N0:?} PoS ${SAVED_POS:?} ${AVG_POS_TIME:?}${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    echo
    printf '%b' "${GR:?}${LOG_DATE:?} Status() - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    echo
    if [[ "$KEEP_DEBUG" -eq "1" ]] &>/dev/null; then
      # keep old log (debug.log)
      printf '%b' "${LOG_DATE:?} Status() Old.DebugLog() Storing old wallet log --> ${GR:?}${WALLET_DIR:?}/debug.log${G1:?}${N0:?} <--${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
      cat "${WALLET_LOG_DIR:?}"/debug.log >>"${WALLET_DIR:?}"/debug.log 2>/dev/null
    fi

    # remove lock file (auto pos config)
    rm "${WALLET_DIR:?}"/diff.lock &>/dev/null

    # reset old files
    truncate -s 0 "${WALLET_DIR:?}"/getwan &>/dev/null
    truncate -s 0 "${WALLET_DIR:?}"/staking &>/dev/null
    truncate -s 0 "${LOG_DIR:?}"/node_data/peers.ipv4.r &>/dev/null
    truncate -s 0 "${LOG_DIR:?}"/node_data/peers.ipv6.r &>/dev/null
    truncate -s 0 "${LOG_DIR:?}"/node_data/stats/total.cidr &>/dev/null

    # truncate old log (debug.log)
    truncate -s 0 "${WALLET_LOG_DIR:?}"/debug.log &>/dev/null
    # report hardware model at start of log
    printf '%b' "${LOG_DATE:?} Status() SystemHardware $(cat /proc/device-tree/model 2>/dev/null | tr -d '\0' 2>&1)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log
    printf '%b' "${LOG_DATE:?} Status() Clean.truncate Cleaning log(s), list(s), Internet data${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

if [ ! -f "${WALLET_DIR:?}"/failed ] &>/dev/null; then
  # make sure backup failed exist
  touch "${WALLET_DIR:?}"/failed &>/dev/null
fi

# do this once
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then
  if ! grep "Never connected()" "${WALLET_LOG_DIR:?}"/debug.log &>/dev/null; then
    if [ ! -s "${WALLET_DIR:?}"/failed ] &>/dev/null; then
      printf '%b' "${LOG_DATE:?} Status() Clean.Backup() Removing empty failed.tmp +$(wc -l "${WALLET_DIR:?}"/failed 2>&1 | awk '{ print $1 }' 2>&1)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
      rm "${WALLET_DIR:?}"/failed &>/dev/null
    fi
    # use old failed list as a continuation to the next day, ruled by -lines above
    if [[ "$(wc -l "${WALLET_DIR:?}"/failed 2>&1 | awk '{ print $1 }' 2>&1)" -gt "$(wc -l "${LOG_DIR:?}"/node_data/peers/failed 2>&1 | awk '{ print $1 }' 2>&1)" ]] &>/dev/null; then
      # add failed peers (failed.tmp) back in to debug.log
      while IFS= read -r ADDS; do
        echo "${LOG_DATE:?} Status() connect to ${ADDS:?} failed -> Never connected()" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
      done <"${WALLET_DIR:?}"/failed 2>&1 | awk '!a[$0]++' 2>&1 | sort -R 2>&1
      printf '%b' "${LOG_DATE:?} Status() Clean.Backup() Restoring old failed list, failed.tmp +$(wc -l "${WALLET_DIR:?}"/failed 2>&1 | awk '{ print $1 }' 2>&1)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    else
      DIS_LOCAL=$(echo "$(cat "${LOG_DIR:?}"/node_data/stats/ip_address 2>/dev/null)" 2>&1 | egrep -o "[0-9]+" 2>&1 | head -1 2>&1)
      # keep last n of failed connections
      RANDOM_FAILED=$((((RANDOM % 512) + 256)))
      echo "$(tail -"${RANDOM_FAILED:?}" "${LOG_DIR:?}"/node_data/peers/failed 2>&1 | grep -v "${DIS_LOCAL:?}" 2>&1)" 2>&1 | awk '!a[$0]++' >"${WALLET_DIR:?}"/failed 2>&1
    fi
  fi
fi

### timeline ###################################################################

if grep -o "progress=1.000000" "${LOG_DIR:?}"/node_data/synced &>/dev/null; then

  # if rpc in warm-up, loading block index, wait
  if [ -f "${LOG_DIR:?}"/node_data/client/getblockchaininfo ] &>/dev/null; then

    # random start number
    RANDOM_TIMELINE=$((((RANDOM % 18) + 1)))

    if [[ -z "$RANDOM_TIMELINE" ]] &>/dev/null; then
      # non responsive, go with difficulty
      RANDOM_TIMELINE="1"
    fi

    # difficulty
    if [ "$RANDOM_TIMELINE" -eq "1" ] &>/dev/null; then
      TIMELINE=$(cat "${LOG_DIR:?}"/node_data/stats/difficulty 2>/dev/null | tail -1)
      TIMELINE="Difficulty $TIMELINE"
    # patriotnodes
    elif [ "$RANDOM_TIMELINE" -eq "2" ] &>/dev/null; then
      TIMELINE="Patriotnodes ${N0:?}${WALLET_NODES_STABLE:?}${N0:?}/${G1:?}${WALLET_NODES_TOTAL:?}${N0:?}/${G0:?}${WALLET_NODES_ENABLED:?}${N0:?}/${GR:?}${WALLET_NODES_INQUEUE:?}${N0:?}"
    # moneysupply
    elif [ "$RANDOM_TIMELINE" -eq "3" ] &>/dev/null; then
      TIMELINE=$(grep "moneysupply" "${LOG_DIR:?}"/node_data/client/getinfo 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1 | rev 2>&1 | sed "s#[[:digit:]]\{3\}#&,#g" 2>&1 | rev 2>&1 | sed 's/^,//g' 2>&1)
      TIMELINE="Moneysupply $TIMELINE${N0:?}"
    # unconfirmed_balance
    elif [ "$RANDOM_TIMELINE" -eq "4" ] &>/dev/null; then
      WALLET_UNCONFIRMED_VALUE=$(echo "$WALLET_UNCONFIRMED*$(tail -1 "${LOG_DIR:?}"/node_data/stats/price 2>&1)" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1 | tail -1 2>&1)
      if [[ "$HIDE_BALANCE" -eq "1" ]] &>/dev/null; then
        # hide unconfirmed
        TIMELINE="Unconfirmed ${GR:?}****${N0:?} ${GR:?}****${N0:?} USD${N0:?}"
      else
        TIMELINE="Unconfirmed $WALLET_UNCONFIRMED ${GR:?}$WALLET_UNCONFIRMED_VALUE USD${N0:?}"
      fi
    # immature_balance
    elif [ "$RANDOM_TIMELINE" -eq "5" ] &>/dev/null; then
      WALLET_IMMATURE_VALUE=$(echo "$WALLET_IMMATURE*$(tail -1 "${LOG_DIR:?}"/node_data/stats/price 2>&1)" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1 | tail -1 2>&1)
      if [[ "$HIDE_BALANCE" -eq "1" ]] &>/dev/null; then
        # hide immature
        TIMELINE="Immature ${GR:?}****${N0:?} ${GR:?}****${N0:?} USD${N0:?}"
      else
        TIMELINE="Immature $WALLET_IMMATURE ${GR:?}$WALLET_IMMATURE_VALUE USD${N0:?}"
      fi
    elif [ "$RANDOM_TIMELINE" -eq "6" ] &>/dev/null; then
      # lowest confirmation
      TIMELINE_CONF=$(grep "confirmations" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | sort -n 2>&1 | head -1 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      # calculate seconds
      TIMELINE_SEC=$(echo "$TIMELINE_CONF*60" 2>&1 | bc -l 2>&1 | awk -F. '{ print $1 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      # calculate seconds into age
      if [[ -f "${LOG_DIR:?}"/node_data/client/listunspent ]] &>/dev/null; then
        INPUT_AGE=$(printf '%dh:%dm' $(("$TIMELINE_SEC/3600")) $(("$TIMELINE_SEC%3600/60")))
        INPUT_AGE_D=$(echo "$(echo "$INPUT_AGE" 2>&1 | egrep -o "[0-9]+h" 2>&1 | tr -d 'h' 2>&1)/24" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      fi
      if [[ -z "$TIMELINE_CONF" ]] &>/dev/null; then
        # non responsive
        TIMELINE_CONF="${GR:?}0${N0:?}"
      fi
      if [[ "$HIDE_BALANCE" -eq "1" ]] &>/dev/null; then
        # hide new input
        TIMELINE="New Input ${GR:?}****${N0:?} (${GR:?}****${N0:?}) ${GR:?}****${N0:?}${N0:?}"
      else
        TIMELINE="New Input $TIMELINE_CONF (${INPUT_AGE_D:?}d) ${GR:?}$INPUT_AGE${N0:?}"
      fi
    elif [ "$RANDOM_TIMELINE" -eq "7" ] &>/dev/null; then
      # highest confirmation
      TIMELINE_CONF=$(grep "confirmations" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | sort -n 2>&1 | tail -1 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      # calculate seconds
      TIMELINE_SEC=$(echo "$TIMELINE_CONF*60" 2>&1 | bc -l 2>&1 | awk -F. '{ print $1 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      # calculate seconds into age
      INPUT_AGE=$(printf '%dh:%dm' $(("$TIMELINE_SEC/3600")) $(("$TIMELINE_SEC%3600/60")))
      INPUT_AGE_D=$(echo "$(echo "$INPUT_AGE" 2>&1 | egrep -o "[0-9]+h" 2>&1 | tr -d 'h' 2>&1)/24" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      if [[ -z "$TIMELINE_CONF" ]] &>/dev/null; then
        # non responsive
        TIMELINE_CONF="${GR:?}0${N0:?}"
      fi
      if [[ "$HIDE_BALANCE" -eq "1" ]] &>/dev/null; then
        # hide old input
        TIMELINE="Old Input ${GR:?}****${N0:?} (${GR:?}****${N0:?}) ${GR:?}****${N0:?}${N0:?}"
      else
        TIMELINE="Old Input $TIMELINE_CONF (${INPUT_AGE_D:?}d) ${GR:?}$INPUT_AGE${N0:?}"
      fi

      # average confirmation
    elif [ "$RANDOM_TIMELINE" -eq "8" ] &>/dev/null; then
      UNSPENT_COUNT=$(grep "confirmations" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | wc -l 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      TIMELINE=$(grep "confirmations" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ SUM += $1} END { print SUM }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      # average calculated
      TIMELINE_AVG=$(echo "$TIMELINE/$UNSPENT_COUNT" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      if [[ -z "$TIMELINE_AVG" ]] &>/dev/null; then
        # non responsive
        TIMELINE_AVG="${GR:?}0${N0:?}"
      fi
      # calculate seconds
      TIMELINE_SEC=$(echo "$TIMELINE_AVG*60" 2>&1 | bc -l 2>&1 | awk -F. '{ print $1 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      # calculate seconds into age
      INPUT_AGE=$(printf '%dh:%dm' $(("${TIMELINE_SEC:?}/3600")) $(("${TIMELINE_SEC:?}%3600/60")))
      # save the value
      echo "${INPUT_AGE:?}" >"${LOG_DIR:?}"/node_data/stats/avgconfirmation
      INPUT_AGE_D=$(echo "$(echo "$INPUT_AGE" 2>&1 | egrep -o "[0-9]+h" 2>&1 | tr -d 'h' 2>&1)/24" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      TIMELINE="Average $TIMELINE_AVG (${INPUT_AGE_D:?}d) ${GR:?}$INPUT_AGE${N0:?}"
      # wallet value
    elif [ "$RANDOM_TIMELINE" -eq "9" ] &>/dev/null; then
      if [[ "$HIDE_BALANCE" -eq "1" ]] &>/dev/null; then
        # hide value
        TIMELINE="Value ${GR:?}****${N0:?} USD ${GR:?}****${N0:?}"
      else
        TIMELINE="Value ${WALLET_VALUE:?} USD ${GR:?}$WALLET_TICKER${N0:?}"
      fi
      # highest input amount
    elif [ "$RANDOM_TIMELINE" -eq "10" ] &>/dev/null; then
      TIMELINE=$(grep "amount" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | sort -n 2>&1 | tail -1 2>&1 | awk '{ printf "%.8f\n", $1 }' 2>&1)
      if [[ -z "$TIMELINE" ]] &>/dev/null; then
        # non responsive
        TIMELINE="${GR:?}0${N0:?}"
      fi
      if [[ "$HIDE_BALANCE" -eq "1" ]] &>/dev/null; then
        # hide highest input
        TIMELINE="Highest Input ${GR:?}****${N0:?}"
      else
        TIMELINE="Highest Input $TIMELINE"
      fi
      # lowest input amount
    elif [ "$RANDOM_TIMELINE" -eq "11" ] &>/dev/null; then
      TIMELINE=$(grep "amount" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | sort -n 2>&1 | head -1 2>&1 | awk '{ printf "%.8f\n", $1 }' 2>&1)
      if [[ -z "$TIMELINE" ]] &>/dev/null; then
        # non responsive
        TIMELINE="${GR:?}0${N0:?}"
      fi
      if [[ "$HIDE_BALANCE" -eq "1" ]] &>/dev/null; then
        # hide lowest input
        TIMELINE="Lowest Input ${GR:?}****${N0:?}"
      else
        TIMELINE="Lowest Input $TIMELINE"
      fi
      # wallet (daemon) uptime
    elif [ "$RANDOM_TIMELINE" -eq "12" ] &>/dev/null; then
      TIMELINE=$(printf '%dh:%dm:%ds\n' $(("$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)/3600")) $(("$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)%3600/60")) $(("$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)%60")))
      TIMELINE_DAYS=$(echo "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)/86400" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
      TIMELINE="Wallet (${TIMELINE_DAYS:?}d) ${GR:?}$TIMELINE${N0:?}"
    elif [ "$RANDOM_TIMELINE" -eq "13" ] &>/dev/null; then
      # highest peer count
      HIGH_P2P=$(cat "${LOG_DIR:?}"/node_data/stats/connections 2>/dev/null | egrep "[0-9]+" 2>&1 | sort -n 2>&1 | tail -1 2>&1)
      # lowest peer count
      LOWS_P2P=$(cat "${LOG_DIR:?}"/node_data/stats/connections 2>/dev/null | egrep "[0-9]+" 2>&1 | sort -n 2>&1 | head -1 2>&1)
      TIMELINE="Low/High P2P $LOWS_P2P/$HIGH_P2P"
    elif [ "$RANDOM_TIMELINE" -eq "14" ] &>/dev/null; then
      TIMELINE_LINES=$(wc -l "${LOG_DIR:?}"/node_data/stats/mempool 2>&1 | awk '{ print $1 }' 2>&1)
      TIMELINE_ACTIVE=$(grep "1" "${LOG_DIR:?}"/node_data/stats/mempool 2>&1 | wc -l 2>&1)
      TIMELINE_NOACTIVE=$(grep "0" "${LOG_DIR:?}"/node_data/stats/mempool 2>&1 | wc -l 2>&1)
      TIMELINE_PERC_ACTIVE=$(echo "100/$TIMELINE_LINES*$TIMELINE_ACTIVE" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
      TIMELINE_PERC_NOACTIVE=$(echo "100/$TIMELINE_LINES*$TIMELINE_NOACTIVE" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
      TIMELINE_PERC_ACTIVE="${TIMELINE_PERC_ACTIVE:?}%"
      TIMELINE_PERC_NOACTIVE="${TIMELINE_PERC_NOACTIVE:?}%"
      TIMELINE="${N0:?}Alive ${TIMELINE_PERC_ACTIVE:?} Dead ${TIMELINE_PERC_NOACTIVE:?}${N0:?}"
    elif [ "$RANDOM_TIMELINE" -eq "15" ] &>/dev/null; then
      # interface icon (top right)
      INTERFACE=$(egrep "wlan*|eth*" "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1 | grep -B1 "inet" 2>&1 | egrep -o "wlan[0-9]+|eth[0-9]+" 2>&1)
      # interface w speed
      if [[ "$(grep "wlan" "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1)" ]] &>/dev/null; then
        TIMELINE="$(cat "${LOG_DIR:?}"/node_data/stats/iwconfig 2>&1 | grep "Bit" 2>&1 | awk '{ print $2 }' 2>&1 | egrep -o "[0-9]+.[0-9]+" 2>&1)"
        if [[ -z "$TIMELINE" ]] &>/dev/null; then
          # non responsive
          TIMELINE="0"
        fi
        TIMELINE="${TIMELINE:?}Mbs"
      else
        TIMELINE="$(sudo ethtool "${INTERFACE:?}" 2>&1 | grep "Speed" 2>&1 | awk '{ print $2 }' 2>&1 | tr -d '/' 2>&1)"
      fi
      TIMELINE="Network ${INTERFACE:?} ${TIMELINE:?}"
    elif [ "$RANDOM_TIMELINE" -eq "16" ] &>/dev/null; then
      # get cpu information
      TIMELINE=$(printf '%b' "$(cat "${LOG_DIR:?}"/node_data/stats/cpuinfo 2>/dev/null)" 2>&1)
    elif [ "$RANDOM_TIMELINE" -eq "17" ] &>/dev/null; then
      TIMELINE="${SYS_UPTIME:?}"
    # get model info
    elif [ "$RANDOM_TIMELINE" -eq "18" ] &>/dev/null; then
      if [[ ! -f "${LOG_DIR:?}"/node_data/stats/model ]] &>/dev/null; then
        cat /proc/device-tree/model 2>/dev/null | tr -d '\0' >"${LOG_DIR:?}"/node_data/stats/model 2>&1
      fi
      TIMELINE_MODEL=$(cat "${LOG_DIR:?}"/node_data/stats/model 2>/dev/null)
      TIMELINE_MODEL="Model ${TIMELINE_MODEL:?}"
      if [[ -z "$TIMELINE_MODEL" ]] &>/dev/null; then
        TIMELINE_MODEL="${GR:?}Unknown${N0:?}"
      fi
    fi
  fi
fi

if [[ -z "$TIMELINE" ]] &>/dev/null; then
  # wait on wallet w random quotes
  # random start number
  RANDOM_TIMELINE=$((((RANDOM % 10) + 1)))
  # quotes - art of the deal
  if [ "$RANDOM_TIMELINE" -eq "1" ] &>/dev/null; then
    TIMELINE="${GR}Think big${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "2" ] &>/dev/null; then
    TIMELINE="${GR}Maximize your options${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "3" ] &>/dev/null; then
    TIMELINE="${GR}Know your market${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "4" ] &>/dev/null; then
    TIMELINE="${GR}Use your leverage${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "5" ] &>/dev/null; then
    TIMELINE="${GR}Enhance your location${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "6" ] &>/dev/null; then
    TIMELINE="${GR}Get the word out${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "7" ] &>/dev/null; then
    TIMELINE="${GR}Fight back${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "8" ] &>/dev/null; then
    TIMELINE="${GR}Deliver the goods${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "9" ] &>/dev/null; then
    TIMELINE="${GR}Contain the costs${N0:?}"
  elif [ "$RANDOM_TIMELINE" -eq "10" ] &>/dev/null; then
    TIMELINE="${GR}Have fun${N0:?}"
  fi
fi

# less than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -lt "${WAIT_TIME:?}" ]] &>/dev/null; then
  WALLET_TXLAST="${CY:?}       Loading${N0:?}"
fi

### collect data for rrdtool (round robin databases) ###########################

# greater than n seconds, continue
if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  if [[ "$GRAPH_STATS" -eq "1" ]] &>/dev/null; then

    # echo values into files (no color)
    echo "$TOTAL_MEM_N" 2>&1 | egrep -v "syntax|-" >"${LOG_DIR:?}"/node_data/stats/memtotal 2>&1
    echo "$FREE_MEM_N" 2>&1 | egrep -v "syntax|-" >"${LOG_DIR:?}"/node_data/stats/memfree 2>&1

    cat "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1 | egrep "TX packets" 2>&1 | awk '{ print $5 }' 2>&1 | sort -n 2>&1 | tail -1 2>&1 >"${LOG_DIR:?}"/node_data/stats/txbytes 2>&1
    cat "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1 | egrep "RX packets" 2>&1 | awk '{ print $5 }' 2>&1 | sort -n 2>&1 | tail -1 2>&1 >"${LOG_DIR:?}"/node_data/stats/rxbytes 2>&1

    # setup graphs
    bash /usr/local/bin/include/stats
  fi

  ### hide dashbord balance(s) #################################################

  if [[ "$HIDE_BALANCE" -eq "1" ]] &>/dev/null; then
    # hide balance and inputs
    WALLET_BALANCE="${GR:?}****${N0:?}"
    WALLET_INPUTS="${GR:?}****${N0:?}"
    WALLET_STAKES="${GR:?}****${N0:?}"
    WALLET_TXLAST="${GR:?}$(tr -dc 'a-z' </dev/urandom 2>&1 | head -c 64 2>&1 | rev 2>&1)${N0:?}"
  fi
fi

# restore lost values ##########################################################

if tail -21 "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | grep "Removing empty API" &>/dev/null; then
  # get some api data
  source /usr/local/bin/include/data
  printf '%b' "${LOG_DATE:?} Status() PreFetch.API() Looking for API data.${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
fi

### backup values coingecko ####################################################

if [ -f "${LOG_DIR:?}"/node_data/stats/price.cg ] &>/dev/null; then

  if [[ ! -f "${WALLET_DIR:?}"/price.cg ]] &>/dev/null; then
    # create backup if missing
    cp "${LOG_DIR:?}"/node_data/stats/price.cg "${WALLET_DIR:?}"/price.cg 2>&1
  fi

else # restore it
  if [[ -f "${WALLET_DIR:?}"/price.cg ]] &>/dev/null; then
    cp "${WALLET_DIR:?}"/price.cg "${LOG_DIR:?}"/node_data/stats/price.cg 2>&1
    printf '%b' "${LOG_DATE:?} Status() Coingcko.API() Restored API ${G1:?}$(egrep "[0-9]+" "${LOG_DIR:?}"/node_data/stats/price.cg 2>&1 | awk '{ printf "%.4f\n", $1 }' 2>&1)${N0:?} Price! (CG)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

if [ -f "${LOG_DIR:?}"/node_data/stats/volume.cg ] &>/dev/null; then

  if [[ ! -f "${WALLET_DIR:?}"/volume.cg ]] &>/dev/null; then
    # create backup if missing
    cp "${LOG_DIR:?}"/node_data/stats/volume.cg "${WALLET_DIR:?}"/volume.cg 2>&1
  fi

else # restore it
  if [[ -f "${WALLET_DIR:?}"/volume.cg ]] &>/dev/null; then
    cp "${WALLET_DIR:?}"/volume.cg "${LOG_DIR:?}"/node_data/stats/volume.cg 2>&1
    printf '%b' "${LOG_DATE:?} Status() Coingcko.API() Restored API ${G1:?}$(egrep "[0-9]+" "${LOG_DIR:?}"/node_data/stats/volume.cg 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)${N0:?} Volume! (CG)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

# remove empty files, try to restore
if [ ! -s "${LOG_DIR:?}"/node_data/stats/price.cg ] &>/dev/null; then
  rm "${LOG_DIR:?}"/node_data/stats/price.cg &>/dev/null
  printf '%b' "${LOG_DATE:?} Status() Coingcko.API() Removing empty API Price! (CG)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  cp "${WALLET_DIR:?}"/price.cg "${LOG_DIR:?}"/node_data/stats/price.cg 2>&1
fi

### backup values coinmarketcap ################################################

if [ -f "${LOG_DIR:?}"/node_data/stats/rank.cmc ] &>/dev/null; then

  if [[ ! -f "${WALLET_DIR:?}"/rank.cmc ]] &>/dev/null; then
    # create backup if missing
    cp "${LOG_DIR:?}"/node_data/stats/rank.cmc "${WALLET_DIR:?}"/rank.cmc 2>&1
  fi

else # restore it
  if [[ -f "${WALLET_DIR:?}"/rank.cmc ]] &>/dev/null; then
    cp "${WALLET_DIR:?}"/rank.cmc "${LOG_DIR:?}"/node_data/stats/rank.cmc 2>&1
    printf '%b' "${LOG_DATE:?} Status() CoinMCap.API() Restored API ${G1:?}$(egrep "[0-9]+" "${LOG_DIR:?}"/node_data/stats/rank.cmc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)${N0:?} Rank! (CMC)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

if [ -f "${LOG_DIR:?}"/node_data/stats/price.cmc ] &>/dev/null; then

  if [[ ! -f "${WALLET_DIR:?}"/price.cmc ]] &>/dev/null; then
    # create backup if missing
    cp "${LOG_DIR:?}"/node_data/stats/price.cmc "${WALLET_DIR:?}"/price.cmc 2>&1
  fi

else # restore it
  if [[ -f "${WALLET_DIR:?}"/price.cmc ]] &>/dev/null; then
    cp "${WALLET_DIR:?}"/price.cmc "${LOG_DIR:?}"/node_data/stats/price.cmc 2>&1
    printf '%b' "${LOG_DATE:?} Status() CoinMCap.API() Restored API ${G1:?}$(egrep "[0-9]+" "${LOG_DIR:?}"/node_data/stats/price.cmc 2>&1 | awk '{ printf "%.4f\n", $1 }' 2>&1)${N0:?} Price! (CMC)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

if [ -f "${LOG_DIR:?}"/node_data/stats/volume.cmc ] &>/dev/null; then

  if [[ ! -f "${WALLET_DIR:?}"/volume.cmc ]] &>/dev/null; then
    # create backup if missing
    cp "${LOG_DIR:?}"/node_data/stats/volume.cmc "${WALLET_DIR:?}"/volume.cmc 2>&1
  fi

else # restore it
  if [[ -f "${WALLET_DIR:?}"/volume.cmc ]] &>/dev/null; then
    cp "${WALLET_DIR:?}"/volume.cmc "${LOG_DIR:?}"/node_data/stats/volume.cmc 2>&1
    printf '%b' "${LOG_DATE:?} Status() CoinMCap.API() Restored API ${G1:?}$(egrep "[0-9]+" "${LOG_DIR:?}"/node_data/stats/volume.cmc 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)${N0:?} Volume! (CMC)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

if [ -f "${LOG_DIR:?}"/node_data/stats/watchers.cmc ] &>/dev/null; then

  if [[ ! -f "${WALLET_DIR:?}"/watchers.cmc ]] &>/dev/null; then
    # create backup if missing
    cp "${LOG_DIR:?}"/node_data/stats/watchers.cmc "${WALLET_DIR:?}"/watchers.cmc 2>&1
  fi

else # restore it
  if [[ -f "${WALLET_DIR:?}"/watchers.cmc ]] &>/dev/null; then
    cp "${WALLET_DIR:?}"/watchers.cmc "${LOG_DIR:?}"/node_data/stats/watchers.cmc 2>&1
    printf '%b' "${LOG_DATE:?} Status() CoinMCap.API() Restored API ${G1:?}$(egrep "[0-9]+" "${LOG_DIR:?}"/node_data/stats/watchers.cmc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)${N0:?} Watchlist! (CMC)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  fi
fi

# remove empty files, try to restore
if [ ! -s "${LOG_DIR:?}"/node_data/stats/price.cmc ] &>/dev/null; then
  rm "${LOG_DIR:?}"/node_data/stats/price.cmc &>/dev/null
  printf '%b' "${LOG_DATE:?} Status() CoinMCap.API() Removing empty API Price! (CMC)${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
  cp "${WALLET_DIR:?}"/price.cmc "${LOG_DIR:?}"/node_data/stats/price.cmc 2>&1
fi

### theme ######################################################################

# darkmode (grey)
RC="${GR:?}"
TH="${RC:?}D${N0:?}"

### proof-of-stake block was signed ############################################

if tail -256 "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | grep "BitcoinMiner" &>/dev/null; then
  # green
  CB="${G1:?}"
else # default (theme based)
  CB="${RC:?}"
fi

# END
