#!/bin/bash

# By Rainman
# V20220103
# 0.2.9.5

# shellcheck disable=SC2154

source /usr/local/bin/include/pinode.conf 2>&1
source /usr/local/bin/include/color 2>&1

# date for logs
LOG_DATE=$(cat "${LOG_DIR:?}"/node_data/stats/date 2>/dev/null)
if [[ -z "$LOG_DATE" ]] &>/dev/null; then
  LOG_DATE=$(LC_ALL=de_US.utf8 date '+%Y-%m-%dT%TZ' 2>&1)
fi

# waiting values
WAIT_TIME=$(head -1 "${WALLET_DIR:?}"/wait 2>&1)

# non responsive, use default timer
if [[ -z "$WAIT_TIME" ]] &>/dev/null; then
  WAIT_TIME="360"
  echo "${WAIT_TIME:?}" >"${WALLET_DIR:?}"/wait
fi

RANDOM_WAIT=$((((RANDOM % 2) + 1)))
echo "$RANDOM_WAIT" >"${LOG_DIR:?}"/node_data/waiting 2>&1
RANDOM_WAIT=$(cat "${LOG_DIR:?}"/node_data/waiting 2>/dev/null)
if [[ -z "$RANDOM_WAIT" ]] &>/dev/null; then
  # non responsive
  RANDOM_WAIT="2"
fi

### data dependencies ##########################################################

# make sure screen is installed
if ! [ -x "$(command -v curl)" ] &>/dev/null; then
  echo "Installing curl"
  sudo apt-get install curl -y
  echo
  read -t 1 -r -p "[Ok] curl installed!" </dev/tty
  echo
fi
# make sure rrdtool is installed
if ! [ -x "$(command -v rrdtool)" ] &>/dev/null; then
  echo "Installing rrdtool"
  sudo apt-get install rrdtool -y
  echo
  read -t 1 -r -p "[Ok] rrdtool installed!" </dev/tty
  echo
fi
# make sure html2text is installed
if ! [ -x "$(command -v html2text)" ] &>/dev/null; then
  echo "Installing html2text"
  sudo apt-get install html2text -y
  echo
  read -t 1 -r -p "[Ok] html2text installed!" </dev/tty
  echo
fi

if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "${WAIT_TIME:?}" ]] &>/dev/null; then

  ### arp -a intranet - local network ##########################################

  # add local address (arp) intranet, no ports on these, ignore common default router ip address
  sleep "${RANDOM_WAIT:?}" && arp -a 2>&1 | grep -vwE "(127.0.0.1|192.168.1.1|192.168.0.1|192.168.1.10.1|192.168.2.1|192.168.1.254|192.168.0.30|192.168.0.50|10.0.0.2|10.1.1.1|10.0.1.1|10.0.0.1|10.0.0.138|10.10.1.1)" 2>&1 | egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/node_data/nodes.arp 2>&1

  # get new.arp count
  ARP_NEW=$(wc -l "${LOG_DIR:?}"/node_data/nodes.arp 2>&1 | awk '{ print $1 }' 2>&1)

  # setup arp file
  cat "${LOG_DIR:?}"/node_data/nodes.arp 2>/dev/null | sort -n 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/node_data/nodes.all 2>&1
  printf '%b' "${LOG_DATE:?} Status() Intranet.ARP() Found ${G1:?}${ARP_NEW:?}${N0:?} Peers!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

  ### chainz.cryptoid nodes ####################################################

  # add node address (api) internet, (ipv4) no ports on these
  sleep "${RANDOM_WAIT:?}" && torify curl -s https://chainz.cryptoid.info/freed/api.dws?q=nodes 2>&1 | egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/node_data/nodes.api 2>&1

  # get new count
  API_NEW=$(wc -l "${LOG_DIR:?}"/node_data/nodes.api 2>&1 | awk '{ print $1 }' 2>&1)

  # setup api file
  cat "${LOG_DIR:?}"/node_data/nodes.api 2>/dev/null | sort -n 2>&1 | awk '!a[$0]++' >>"${LOG_DIR:?}"/node_data/nodes.all 2>&1
  printf '%b' "${LOG_DATE:?} Status() Chainz.C.API() Found ${G1:?}${API_NEW:?}${N0:?} Peers!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
fi

# remove duplicates and create peers.tmp
# disregard invalid pattern address (cidr - classless inter-domain routing)
grepcidr -f "${LOG_DIR:?}"/node_data/nodes.all "${LOG_DIR:?}"/node_data/nodes.all 2>&1 | sort -n 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/node_data/peers.tmp 2>"${LOG_DIR:?}"/node_data/peers.cidr

### getnodeaddresses ###########################################################

# get node address with client, max n
NODE_LIMIT="${MAX_P2P:?}"

if [[ -z "$NODE_LIMIT" ]] &>/dev/null; then
  # random nodes
  RANDOM_NODES=$((((RANDOM % 125) + 1)))
  NODE_LIMIT=$(echo "${RANDOM_NODES:?}")
fi

"${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" getnodeaddresses "${NODE_LIMIT:?}" 2>&1 | grep "address" 2>&1 | awk '{ print $2 }' 2>&1 | tr -d '"|,' 2>&1 | sort -n >"${LOG_DIR:?}"/node_data/nodes.get 2>&1

# get new count
GET_NEW=$(wc -l "${LOG_DIR:?}"/node_data/nodes.get 2>&1 | awk '{ print $1 }' 2>&1)

# setup get file
cat "${LOG_DIR:?}"/node_data/nodes.get 2>/dev/null | sort -n 2>&1 | awk '!a[$0]++' >>"${LOG_DIR:?}"/node_data/peers.tmp 2>&1
printf '%b' "${LOG_DATE:?} Status() Get.NodeAddr() Found ${G1:?}${GET_NEW:?}${N0:?} Peers!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

# get total count
TOTAL_NODES=$(echo "${API_NEW:?}+${ARP_NEW:?}+${GET_NEW:?}" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
printf '%b' "${LOG_DATE:?} Status() Addnode.Script Total ${G1:?}${TOTAL_NODES:?}${N0:?} Peers!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

# sort peers.tmp, remove duplicates and grepcidr lines
cat "${LOG_DIR:?}"/node_data/peers.tmp 2>/dev/null | sort -n 2>&1 | grep -v "grepcidr" 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/peers.tmp 2>&1
mv "${LOG_DIR:?}"/peers.tmp "${LOG_DIR:?}"/node_data/peers.tmp 2>&1

### coingecko price, volume ####################################################

cat >"${LOG_DIR:?}"/add_cg <<'EOF'
#!/bin/bash

# By Rainman
# V20221502
# 0.0.3.3

source /usr/local/bin/include/pinode.conf
source /usr/local/bin/include/color

# date for logs
LOG_DATE=$(cat "${LOG_DIR:?}"/node_data/stats/date 2>/dev/null)

printf '%b' "${LOG_DATE:?} Status() Coingcko.API() Fetching CoinGecko API data!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

# remove requests
truncate -s 0 "${LOG_DIR:?}"/node_data/requests.cg

for (( ; ; )); do # loop until success

  clear
  torify curl -o "${LOG_DIR:?}"/node_data/stats/raw.coingcko -X 'GET' 'https://api.coingecko.com/api/v3/coins/'${COING_API:?}'/market_chart?vs_currency='${EXCHA_API:?}'&days='$days'' -H 'accept: application/json' &>/dev/null

  sleep 2
  echo "fail" >>"${LOG_DIR:?}"/node_data/requests.cg 2>&1

  if egrep "[0-9]+" "${LOG_DIR:?}"/node_data/stats/raw.coingcko &>/dev/null; then
    echo "success" >>"${LOG_DIR:?}"/node_data/requests.cg 2>&1
    printf '%b' "${LOG_DATE:?} Status() Coingcko.API() ${G1:?}Success!${N0:?} Found API Data! After ${CY:?}$(wc -l "${LOG_DIR:?}"/node_data/requests.cg 2>&1 | awk '{ print $1 }' 2>&1)${N0:?} requests\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    killall curl &>/dev/null
    exit
  fi

done
EOF

# api values
API_PRICE_CG=$(cat "${LOG_DIR:?}"/node_data/stats/price 2>/dev/null | awk '{ printf "%.4f\n", $1 }' 2>&1)
API_VOLUME_CG=$(cat "${LOG_DIR:?}"/node_data/stats/volume 2>/dev/null | awk '{ printf "%.2f\n", $1 }' 2>&1)

### coinmarketcap price, volume, rank, watchlist ###############################

cat >"${LOG_DIR:?}"/add_cmc <<'EOF'
#!/bin/bash

# By Rainman
# V20221502
# 0.0.3.4

source /usr/local/bin/include/pinode.conf
source /usr/local/bin/include/color

# date for logs
LOG_DATE=$(cat "${LOG_DIR:?}"/node_data/stats/date 2>/dev/null)

printf '%b' "${LOG_DATE:?} Status() CoinMCap.API() Fetching CoinMarketCap API data!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1

# remove requests
truncate -s 0 "${LOG_DIR:?}"/node_data/requests.cmc

for (( ; ; )); do # loop until success

  clear
  URL="https://coinmarketcap.com/currencies/${COINM_API:?}/"
  torify curl -s -L "$URL" 2>&1 | html2text >"${LOG_DIR:?}"/node_data/stats/raw.coinmcap 2>&1

  sleep 2
  echo "fail" >>"${LOG_DIR:?}"/node_data/requests.cmc 2>&1

  if grep "freed" "${LOG_DIR:?}"/node_data/stats/raw.coinmcap &>/dev/null; then
    echo "success" >>"${LOG_DIR:?}"/node_data/requests.cmc 2>&1
    printf '%b' "${LOG_DATE:?} Status() CoinMCap.API() ${G1:?}Success!${N0:?} Found API Data! After ${CY:?}$(wc -l "${LOG_DIR:?}"/node_data/requests.cmc 2>&1 | awk '{ print $1 }' 2>&1)${N0:?} requests\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
    killall curl &>/dev/null
    exit
  fi

done
EOF

### screen sessions ############################################################

# create screen list
LC_ALL=de_US.utf8 screen -list >"${LOG_DIR:?}"/node_data/stats/screens 2>&1

RANDOM_WAIT=$(cat "${LOG_DIR:?}"/node_data/waiting 2>/dev/null)
if [[ -z "$RANDOM_WAIT" ]] &>/dev/null; then
  # non responsive
  RANDOM_WAIT="2"
fi

# random api
RANDOM_SCREEN=$((((RANDOM % 2) + 1)))

if [[ -z "$RANDOM_SCREEN" ]] &>/dev/null; then
  # non responsive
  RANDOM_SCREEN="2"
fi

# run with cg
if [[ "$RANDOM_SCREEN" -eq "1" ]] &>/dev/null; then
  # reset requests.cg file
  if grep "success" "${LOG_DIR:?}"/node_data/requests.cg &>/dev/null; then
    rm "${LOG_DIR:?}"/node_data/requests.cg &>/dev/null
  fi
  sleep "${RANDOM_WAIT:?}"
  # look for screen session, if not found, run this block
  if ! cat "${LOG_DIR:?}"/node_data/stats/screens 2>/dev/null | grep -q "add_cg" &>/dev/null; then
    # create screen session
    screen -dmS add_cg 2>&1
    sleep 1
    screen -S add_cg -X -p 0 stuff $'torify bash '"${LOG_DIR:?}"'/add_cg\n'
  fi
  # create screen list
  LC_ALL=de_US.utf8 screen -list >"${LOG_DIR:?}"/node_data/stats/screens 2>&1
fi

# run with cmc
if [[ "$RANDOM_SCREEN" -eq "2" ]] &>/dev/null; then

  # reset requests file
  if grep "success" "${LOG_DIR:?}"/node_data/requests.cmc &>/dev/null; then
    rm "${LOG_DIR:?}"/node_data/requests.cmc &>/dev/null
  fi
  sleep "${RANDOM_WAIT:?}"
  # look for screen session, if not found, run this block
  if ! cat "${LOG_DIR:?}"/node_data/stats/screens 2>/dev/null | grep -q "add_cmc" &>/dev/null; then
    # create screen session
    screen -dmS add_cmc 2>&1
    sleep 1
    screen -S add_cmc -X -p 0 stuff $'torify bash '"${LOG_DIR:?}"'/add_cmc\n'
  fi
  # create screen list
  LC_ALL=de_US.utf8 screen -list >"${LOG_DIR:?}"/node_data/stats/screens 2>&1
fi

### screen sessions done #######################################################

# if no success, continue
if ! grep "success" "${LOG_DIR:?}"/node_data/requests.cg &>/dev/null; then

  if [[ -z "$API_PRICE_CG" ]] &>/dev/null; then
    # make sure ticker exist, use rrdtool database, if available
    rrdtool info /home/"$(whoami)"/stats/value.rrd 2>&1 | grep "last_ds" 2>&1 | awk '{ print $1 }' 2>&1 | awk '{ printf "%.2f\n", $1 }' >"${LOG_DIR:?}"/node_data/stats/price 2>&1
    # non responsive
    API_PRICE_CG=$(cat "${LOG_DIR:?}"/node_data/stats/price 2>/dev/null | awk '{ printf "%.2f\n", $1 }' 2>&1)
  fi

  if [[ -z "$API_VOLUME_CG" ]] &>/dev/null; then
    # make sure volume exist, use rrdtool database, if available
    rrdtool info /home/"$(whoami)"/stats/volume.rrd 2>&1 | grep "last_ds" 2>&1 | awk '{ print $1 }' 2>&1 | awk '{ printf "%.2f\n", $1 }' >"${LOG_DIR:?}"/node_data/stats/volume 2>&1
    # non responsive
    API_VOLUME_CG=$(cat "${LOG_DIR:?}"/node_data/stats/volume 2>/dev/null | awk '{ printf "%.2f\n", $1 }' 2>&1)
  fi
fi

# if no success, continue
if ! grep "success" "${LOG_DIR:?}"/node_data/requests.cmc &>/dev/null; then
  if [[ -z "$API_PRICE_CMC" ]] &>/dev/null; then
    # make sure ticker exist, use rrdtool database, if available
    rrdtool info /home/"$(whoami)"/stats/value.rrd 2>&1 | grep "last_ds" 2>&1 | awk '{ print $1 }' 2>&1 | awk '{ printf "%.2f\n", $1 }' >"${LOG_DIR:?}"/node_data/stats/price 2>&1
    # non responsive
    API_PRICE_CMC=$(cat "${LOG_DIR:?}"/node_data/stats/price.cmc 2>/dev/null | awk '{ printf "%.2f\n", $1 }' 2>&1)
  fi

  if [[ -z "$API_VOLUME_CMC" ]] &>/dev/null; then
    # make sure volume exist, use rrdtool database, if available
    rrdtool info /home/"$(whoami)"/stats/volume.rrd 2>&1 | grep "last_ds" 2>&1 | awk '{ print $1 }' 2>&1 | awk '{ printf "%.2f\n", $1 }' >"${LOG_DIR:?}"/node_data/stats/volume 2>&1
    # non responsive
    API_VOLUME_CMC=$(cat "${LOG_DIR:?}"/node_data/stats/volume.cmc 2>/dev/null | awk '{ printf "%.2f\n", $1 }' 2>&1)
  fi
fi

# END
