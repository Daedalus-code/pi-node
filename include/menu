#!/bin/bash

# By Rainman
# V20222202
# 2.3.1.6

# dialog, ncurses no utf8 acs
export NCURSES_NO_UTF8_ACS=1

# shellcheck disable=SC2034  # Unused variables left for readability

source /usr/local/bin/include/pinode.conf 2>&1
source /usr/local/bin/include/color 2>&1

# make sure dialog exist
if ! [ -x "$(command -v dialog)" ] &>/dev/null; then
  sudo apt-get install dialog -y
fi

if ! [ -x "$(command -v unzip)" ] &>/dev/null; then
  sudo apt-get install unzip -y
fi

if [[ ! -s "${LOG_DIR:?}"/node_data/client/listunspent ]] &>/dev/null; then
  # non responsive
  POS_COUNT="0"
else # get input count
  POS_COUNT=$(grep "address" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | wc -l 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
fi

# date for logs
LC_ALL=de_US.utf8 date '+%Y-%m-%dT%TZ' >"${LOG_DIR:?}"/node_data/stats/date 2>&1
LOG_DATE=$(cat "${LOG_DIR:?}"/node_data/stats/date 2>/dev/null)

if [[ -z "$LOG_DATE" ]] &>/dev/null; then
  LOG_DATE=$(LC_ALL=de_US.utf8 date '+%Y-%m-%dT%TZ' 2>&1)
fi

# create uname -a
uname -a >"${LOG_DIR:?}"/node_data/uname

# get system user
USER=$(whoami 2>&1 | awk '{ print $1 }' 2>&1)

if cat "${LOG_DIR:?}"/node_data/uname 2>/dev/null | egrep "armv7l|aarch64" &>/dev/null; then
  # get cpu temp, celcius, fahrenheit, (raspberry pi)
  CPU_RAW_TEMP=$(cat /sys/class/thermal/thermal_zone0/temp 2>/dev/null)
else
  CPU_RAW_TEMP="0"
fi
# calculate celcius and fahrenheit
CELCIUS=$(echo "$CPU_RAW_TEMP/100*0.1" 2>&1 | bc -l 2>&1 | awk '{ printf "%.1f\n", $1 }' 2>&1)
FAHRENHEIT=$(echo "scale=2;((9/5) * $CELCIUS) + 32" 2>&1 | bc 2>&1 | awk '{ printf "%.1f\n", $1 }' 2>&1)

CPU_CTEMP="${CELCIUS:?}"
CPU_FTEMP="${FAHRENHEIT:?}"

LATEST_DATE=$(head -1 "${LOG_DIR:?}"/node_data/repo 2>&1)

OLD_HEAD=$(grep "Update.Script" "${WALLET_LOG_DIR:?}"/debug.log 2>&1 | awk '{ print $7 }' 2>&1 | tail -1 2>&1 | sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" 2>&1)
if [[ -z "$OLD_HEAD" ]] &>/dev/null; then
  # non responsive (fsociety)
  OLD_HEAD="${GR:?}[fsociety]${N0:?}"
fi

HEIGHT=17
WIDTH=55
CHOICE_HEIGHT=10
BACKTITLE="Pi-Node - ${OLD_HEAD:?} ${LATEST_DATE:?}"
TITLE="$(grep "inet" "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1 | grep -v "127." 2>&1 | awk '{ print $2 }' 2>&1 | xargs 2>&1 | awk '{ print $1 }' 2>&1) $(grep "inet" "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1 | grep -v "127." 2>&1 | awk '{ print $2 }' 2>&1 | xargs 2>&1 | awk '{ print $2 }' 2>&1)"
MENU=" $(LC_ALL=de_US.utf8 date 2>&1) ${CPU_CTEMP:?}C ${CPU_FTEMP:?}F P2P $(grep "connections" "${LOG_DIR:?}"/node_data/client/getinfo 2>&1 | awk '{ print $2 }' 2>&1)"

OPTIONS=(1 "Wallet Menu      Shutdown, Re/Start node"
  2 "Keys Menu        Dump/Import keys PoS (${POS_COUNT:?})"
  3 "Information      Pi node status"
  4 "Download Menu    Wallet, bootstrap, display"
  5 "Configs & Tools  Node configurations"
  6 "System Space     Disk space utilized"
  7 "Swap Menu        Swap space options"
  8 "UFW Menu         Uncomplicated firewall"
  9 "Tor Menu         Proxy options (tor)"
  10 "Quit             Exit menu")

CHOICE=$(dialog --clear \
  --nocancel \
  --backtitle "$BACKTITLE" \
  --title "$TITLE" \
  --menu "$MENU" \
  $HEIGHT $WIDTH $CHOICE_HEIGHT \
  "${OPTIONS[@]}" \
  2>&1 >/dev/tty)

clear
case $CHOICE in

"1")

  HEIGHT=9
  WIDTH=55
  CHOICE_HEIGHT=2
  BACKTITLE="Pi-Node"
  TITLE="Wallet Menu"
  MENU="Choose one option:"

  OPTIONS=(1 "Shutdown         Stop daemon, reboot system"
    2 "Re/Start         Re/Start daemon ($(pidof "${WALLET_DAEMON:?}" 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1))")

  CHOICE=$(dialog --clear \
    --backtitle "$BACKTITLE" \
    --title "$TITLE" \
    --menu "$MENU" \
    $HEIGHT $WIDTH $CHOICE_HEIGHT \
    "${OPTIONS[@]}" \
    2>&1 >/dev/tty)

  clear
  case $CHOICE in

  # stop node

  "1")

    # turn of wallet daemon
    read -r -p "[YN] Stop node, are you sure? y/n " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

      if [[ "$(cat "${LOG_DIR:?}"/node_data/peers/failed 2>/dev/null)" -gt "$(cat "${WALLET_DIR:?}"/failed 2>/dev/null)" ]] &>/dev/null; then
        cp "${LOG_DIR:?}"/node_data/peers/failed "${WALLET_DIR:?}"/failed 2>&1
      fi # only ask if wallet is not synced
      if ! grep -o "progress=1.00" "${LOG_DIR:?}"/node_data/synced &>/dev/null; then
        read -r -p "[YN] Kill PID?, No for client stop! y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
          # hard shutdown
          kill -9 "$(pidof "${WALLET_DAEMON:?}" 2>&1)" &>/dev/null && sleep 1
        fi
      fi
      # normal shutdown
      printf '%b' "[${R1:?}!!${N0:?}] "
      "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" stop && sleep 5
      # wait on node (daemon) to stop
      until ! pidof "${WALLET_DAEMON:?}" 2>&1 | wc -w 2>&1 | egrep "1" &>/dev/null; do
        clear
        printf '%b' "[${R1:?}!!${N0:?}] waiting on wallet (${G1:?}$(pidof "${WALLET_DAEMON:?}" 2>&1)${N0:?}) daemon to shutdown..\n"
        printf '%b' "[${N0:?}!!${N0:?}] ${GR:?}CTRL+C to exit${N0:?}\n"
        sleep 10
        kill -9 "$(pidof "${WALLET_DAEMON:?}" 2>&1)" &>/dev/null
      done

      read -r -p "[YN] Reboot? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
        sleep 1
        sudo reboot
      fi
    fi
    clear

    ;;

    # restart node

  "2")

    read -r -p "[YN] Re/start node (daemon)? y/n " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

      # stop wallet daemon
      printf '%b' "[${R1:?}!!${N0:?}] $("${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" stop && sleep 5)\n"
      killall "${WALLET_DAEMON:?}" &>/dev/null
      printf '%b' "[${G1:?}Ok${N0:?}] Re/Starting node!\n"

      # make sure debug.log exist
      touch "${WALLET_LOG_DIR:?}"/debug.log 2>&1
      # remove old files
      rm "${LOG_DIR:?}"/node_data/client/tmp/proc &>/dev/null
      rm "${LOG_DIR:?}"/node_data/synced &>/dev/null
      rm "${WALLET_DIR:?}"/getwan &>/dev/null
      rm "${WALLET_DIR:?}"/onion &>/dev/null
      rm "${WALLET_DIR:?}"/wait &>/dev/null

      truncate -s 0 "${WALLET_LOG_DIR:?}"/debug.log &>/dev/null
      sleep 1
      # start node (daemon)
      printf '%b' "[${G1:?}Ok${N0:?}] "
      "${WALLET_DIR:?}"/"${WALLET_DAEMON:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" -debug=tor -proxy="${PROXY:?}" -daemon
      printf '%b' "${LOG_DATE:?} Status() Wallet.Warden: PID(?) Starting wallet daemon!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
      read -r -p "[Ok] Press Enter to continue" </dev/tty
      echo
    fi

    ;;

  esac

  ;;

"2")

  HEIGHT=9
  WIDTH=52
  CHOICE_HEIGHT=2
  BACKTITLE="Pi-Node"
  TITLE="Key Menu"
  MENU="Choose one option:"

  OPTIONS=(1 "Import key       Adds a private key"
    2 "Dump key         Reveals the private key")

  CHOICE=$(dialog --clear \
    --backtitle "$BACKTITLE" \
    --title "$TITLE" \
    --menu "$MENU" \
    $HEIGHT $WIDTH $CHOICE_HEIGHT \
    "${OPTIONS[@]}" \
    2>&1 >/dev/tty)

  clear
  case $CHOICE in

  "1")

    # Import key
    echo "Adds a private key (as returned by dumpprivkey) to your wallet. Requires a new wallet backup.

Note: This call can take minutes to complete if rescan is true, during that time, other rpc calls
may report that the imported key exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.
"
    printf '%b' "Enter private key ${G1:?}>${N0:?} "
    read -r IMPORT_KEY
    if [[ -z "$IMPORT_KEY" ]] &>/dev/null; then
      # non responsive
      printf '%b' "[${R1:?}!!${N0:?}] Nothing was typed!\n"
      sleep 1
      clear
      exit
    fi
    printf '%b' "[${R1:?}!!${GR:?}?${N0:?}] Please wait..! This call can take minutes to complete.\n"
    "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" importprivkey "${IMPORT_KEY:?}"
    clear
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo

    ;;

  "2")

    echo "Reveals the private key corresponding to 'address'.
Then the importprivkey can be used with this output
"
    printf '%b' "Enter address to dump ${G1:?}>${N0:?} "
    read -r DUMP_ADDRESS
    if [[ -z "$DUMP_ADDRESS" ]] &>/dev/null; then
      # non responsive
      printf '%b' "[${R1:?}!!${N0:?}] Nothing was typed!\n"
      sleep 1
      clear
      exit
    fi
    echo "[!?] Please copy this!"
    "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" dumpprivkey "${DUMP_ADDRESS:?}"
    clear
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo

    ;;

  esac

  ;;

"8")

  HEIGHT=14
  WIDTH=46
  CHOICE_HEIGHT=7
  BACKTITLE="Pi-Node"
  TITLE="Uncomplicated firewall Menu"
  MENU="Choose one option:"

  OPTIONS=(1 "Status       Show firewall status"
    2 "Enable       Enables the firewall"
    3 "Disable      Disables the firewall"
    4 "Allow        Add allow rule"
    5 "Deny         Add deny rule"
    6 "Delete All   Delete all rules"
    7 "Use Default  Set default rules")

  CHOICE=$(dialog --clear \
    --backtitle "$BACKTITLE" \
    --title "$TITLE" \
    --menu "$MENU" \
    $HEIGHT $WIDTH $CHOICE_HEIGHT \
    "${OPTIONS[@]}" \
    2>&1 >/dev/tty)

  clear
  case $CHOICE in

  "1")

    display_result() {
      dialog --title "UFW Status" \
        --no-collapse \
        --msgbox "$RESULT" 0 0
    }

    RESULT=$(sudo ufw status verbose 2>&1)
    display_result "Uncomplicated firewall Status"
    clear

    ;;

  "2")

    read -r -p "[YN] Enable firewall? y/n " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
      echo "[Ok] Enabling the firewall"
      sudo ufw enable
      echo
      read -r -p "[Ok] Press Enter to continue" </dev/tty
      echo
    fi

    ;;

  "3")

    read -r -p "[YN] Disable firewall? y/n " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
      echo "[Ok] Disabling the firewall"
      sudo ufw disable
      echo
      read -r -p "[Ok] Press Enter to continue" </dev/tty
      echo
    fi

    ;;

  "4")

    printf '%b' "Example rules using the simple syntax:
ufw allow ${G1:?}53${N0:?}

This rule will allow tcp and udp port 53 to any address on this host.
To specify a protocol, append '/protocol'
to the port. For example:
ufw allow ${G1:?}25/tcp${N0:?}

This will allow tcp port 25 to any address on this host.
ufw will also check /etc/services for the port and pro‐
tocol if specifying a service by name. Eg:

ufw allow ${G1:?}smtp${N0:?}\n"
    echo "Type only value/rule"
    printf '%b' "Enter ${G1:?}> ${N0:?}"
    read -r ALLOW_RULE
    if [[ -z "$ALLOW_RULE" ]] &>/dev/null; then
      # empty
      printf '%b' "[${R1:?}!!${N0:?}] Empty, try again\n"
      exit
    fi
    sudo ufw allow "${ALLOW_RULE:?}"
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo

    ;;

  "5")

    printf '%b' "Example rules using the simple syntax:
ufw deny ${G1:?}53${N0:?}

This rule will deny tcp and udp port 53 to any address on this host.
To specify a protocol, append '/protocol'
to the port. For example:
ufw deny ${G1:?}25/tcp${N0:?}

This will deny tcp port 25 to any address on this host.
ufw will also check /etc/services for the port and pro‐
tocol if specifying a service by name. Eg:

ufw deny ${G1:?}smtp${N0:?}\n"
    echo "Type only value/rule"
    printf '%b' "Enter ${G1:?}> ${N0:?}"
    read -r DENY_RULE
    if [[ -z "$DENY_RULE" ]] &>/dev/null; then
      # empty
      printf '%b' "[${R1:?}!!${N0:?}] Empty, try again\n"
      exit
    fi
    sudo ufw deny "${DENY_RULE:?}"
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo

    ;;

  "6")

    # get wallet port, do this once
    if [[ ! -f "${WALLET_DIR:?}"/wallet_port ]] &>/dev/null; then
      printf '%b' "[??] Enter wallet Port ${G1:?}> ${N0:?}"
      read -r PORT
      echo "${PORT:?}" >"${WALLET_DIR:?}"/wallet_port 2>&1
      if [[ -z "$PORT" ]] &>/dev/null; then
        # empty, exit
        printf '%b' "[${R1:?}!!${N0:?}] Empty, try again\n"
        exit
      fi
    else
      PORT="$(cat "${WALLET_DIR:?}"/wallet_port 2>/dev/null)"
    fi

    # delete ufw rules
    printf '%b' "[${R1:?}!!${N0:?}] Deleting allow rules ${PORT:?}, 80, 22\n"
    sudo ufw delete allow "${PORT:?}"
    sudo ufw delete allow 80
    sudo ufw delete allow 22
    sudo ufw status
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo

    ;;

  "7")

    # get wallet port, do this once
    if [[ ! -f "${WALLET_DIR:?}"/wallet_port ]] &>/dev/null; then
      printf '%b' "[??] Enter wallet Port ${G1:?}> ${N0:?}"
      read -r PORT
      echo "${PORT:?}" >"${WALLET_DIR:?}"/wallet_port 2>&1
      if [[ -z "$PORT" ]] &>/dev/null; then
        # empty, exit
        printf '%b' "[${R1:?}!!${N0:?}] Empty, try again\n"
        exit
      fi
    else
      PORT="$(cat "${WALLET_DIR:?}"/wallet_port 2>/dev/null)"
    fi

    # set default ufw rules
    echo "[Ok] Set allow rules ${PORT:?}, 80, 22"
    sudo ufw allow "${PORT:?}" comment "${WALLET_NAME:?} mainnet"
    sudo ufw allow 80 comment "${WALLET_NAME:?} Graphs"
    sudo ufw allow 22 comment "SSH"
    sudo ufw status
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo

    ;;

  esac

  ;;

"3")

  echo "Please wait"
  # greater than n seconds, continue
  if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "1" ]] &>/dev/null; then

    # get uptime
    UPTIME=$(printf '%dh:%dm:%ds\n' $(("$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)/3600")) $(("$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)%3600/60")) $(("$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)%60")))
    UPTIME_DAYS=$(echo "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)/86400" 2>&1 | bc 2>&1)
    UPTIME="${UPTIME_DAYS:?}d ${UPTIME:?}"

    # get system uptime
    awk -F. ' {print $1 }' /proc/uptime >"${LOG_DIR:?}"/node_data/stats/system.uptime 2>&1
    SYS_UPTIME=$(printf '%dh:%dm:%ds\n' $(("$(cat "${LOG_DIR:?}"/node_data/stats/system.uptime 2>/dev/null)/3600")) $(("$(cat "${LOG_DIR:?}"/node_data/stats/system.uptime 2>/dev/null)%3600/60")) $(("$(cat "${LOG_DIR:?}"/node_data/stats/system.uptime 2>/dev/null)%60")))
    SYS_UPTIME_DAYS=$(echo "$(cat "${LOG_DIR:?}"/node_data/stats/system.uptime 2>/dev/null)/86400" 2>&1 | bc 2>&1)
    SYS_UPTIME="${SYS_UPTIME_DAYS:?}d ${SYS_UPTIME:?}"

    # pidof daemon
    PID_DAEMON=$(pidof "${WALLET_DAEMON:?}" 2>&1)

    # coin supply
    NODE_COIN_SUPPLY=$(grep "moneysupply" "${LOG_DIR:?}"/node_data/client/getinfo 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1 | rev 2>&1 | sed "s#[[:digit:]]\{3\}#&,#g" 2>&1 | rev 2>&1 | sed 's/^,//g' 2>&1)

    # running mainnet or testnet
    if ! "$(grep "main" "${LOG_DIR:?}"/node_data/client/getblockchaininfo 2>&1)" -eq "main" &>/dev/null; then
      # mainnet
      WALLET_CHAIN="mainnet"
    else # testnet
      WALLET_CHAIN="testnet"
    fi

    # staking status
    if [[ "$(grep "Staking Active" "${LOG_DIR:?}"/node_data/client/getinfo 2>&1)" ]] &>/dev/null; then

      # proof-of-stake active
      NODE_PROOF="Active"
    else
      # proof-of-stake not active
      NODE_PROOF="Not active"
    fi

    # get download from wlan(*) - eth(*)
    DOWNLOAD=$(egrep "RX packets [0-9]+  bytes [0-9]+" "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1 | awk '{ print $5 }' 2>&1 | sort -n 2>&1 | tail -1 2>&1)
    # get upload from wlan(*) - eth(*)
    UPLOAD=$(egrep "TX packets [0-9]+  bytes [0-9]+" "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1 | awk '{ print $5 }' 2>&1 | sort -n 2>&1 | tail -1 2>&1)
    # human-readable format
    DOWNLOAD=$(numfmt --to iec --format "%8.3f" "$DOWNLOAD" 2>&1 | xargs 2>&1)
    UPLOAD=$(numfmt --to iec --format "%8.3f" "$UPLOAD" 2>&1 | xargs 2>&1)

    # get blockchain headers
    WALLET_HEADS=$(grep "blocks" "${LOG_DIR:?}"/node_data/client/getblockchaininfo 2>&1 | grep -Eo "[0-9]+" 2>&1)
    # get blockchain block
    WALLET_BLOCK=$(grep "headers" "${LOG_DIR:?}"/node_data/client/getblockchaininfo 2>&1 | grep -Eo "[0-9]+" 2>&1)

    # total connections
    WALLET_PEERS_TOTAL=$(grep "connections" "${LOG_DIR:?}"/node_data/client/getinfo 2>&1 | awk '{ print $2 }' 2>&1)
    # total banned
    WALLET_PEERS_BANNED=$(cat "${LOG_DIR:?}"/node_data/stats/bans 2>/dev/null)

    # get total Memory
    TOTAL_MEM=$(free --mega 2>&1 | grep "Mem" 2>&1 | awk '{ print $2 }' 2>&1)
    TOTAL_SWAP=$(free --mega 2>&1 | grep "Swap" 2>&1 | awk '{ print $2 }' 2>&1)
    # get free Memory
    FREE_MEM=$(free --mega 2>&1 | grep "Mem" 2>&1 | awk '{ print $7 }' 2>&1)
    FREE_SWAP=$(free --mega 2>&1 | grep "Swap" 2>&1 | awk '{ print $4 }' 2>&1)
    # calculate
    TOTAL_MEM=$(echo "$TOTAL_MEM+$TOTAL_SWAP" 2>&1 | bc 2>&1)
    FREE_MEM=$(echo "$FREE_MEM+$FREE_SWAP" 2>&1 | bc 2>&1)
    # total and free memory (rrdtool, no color)
    TOTAL_MEM_RR="$TOTAL_MEM"
    FREE_MEM_RR="$FREE_MEM"

    # users online
    USER=$(users 2>&1 | wc -w 2>&1)

    # system load
    uptime 2>&1 | xargs 2>&1 | egrep -o "[0-9]+.[0-9]+, [0-9]+.[0-9]+, [0-9]+.[0-9]+" 2>&1 | sed 's/\([0-9]\),/\1./g' >"${LOG_DIR:?}"/node_data/stats/load 2>&1
    LOAD=$(cat "${LOG_DIR:?}"/node_data/stats/load 2>/dev/null | egrep -o "[0-9]+.[0-9]+" | xargs 2>&1)

    if [[ -z "$LOAD" ]] &>/dev/null; then
      # non responsive
      LOAD=$(uptime 2>&1 | xargs 2>&1 | egrep -o "[0-9]+.[0-9]+, [0-9]+.[0-9]+, [0-9]+.[0-9]+" 2>&1 | sed 's/\([0-9]\),/\1./g' 2>&1 | egrep -o "[0-9]+.[0-9]+" | xargs 2>&1)
    fi

    # get cpu temp, celcius, fahrenheit, (raspberry pi)
    CPU_CTEMP=$(</sys/class/thermal/thermal_zone0/temp)
    CPU_CTEMP=$(echo "${CPU_CTEMP:?} / 100 * 0.1" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)
    CPU_FTEMP=$(echo "(1.8 * ${CPU_CTEMP:?}) + 32" 2>&1 | bc 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)

    # save lscpu values to lscpu, do this once
    lscpu >"${LOG_DIR:?}"/node_data/stats/lscpu
    # get cpu count
    CPUS=$(grep "CPU(s):" "${LOG_DIR:?}"/node_data/stats/lscpu 2>&1 | awk '{ print $2 }' 2>&1)

    # get cpu count
    CPUS=$(grep "CPU(s):" "${LOG_DIR:?}"/node_data/stats/lscpu 2>&1 | awk '{ print $2 }' 2>&1)

    # get free Space, mmc block device #0, partition #2, partition #2, dev/root
    USED_HDD=$(df -k 2>&1 | egrep "mmcblk0p2|mmcblk0p3|/dev/root" 2>&1 | awk '{ print $3 }' 2>&1)
    # get bytes from kilo
    USED_HDD=$(echo "${USED_HDD:?}*1024" 2>&1 | bc -l 2>&1)
    # human-readable format
    USED_HDD=$(numfmt --to iec --format "%8.3f" "${USED_HDD:?}" 2>&1 | xargs 2>&1)
    # get used hdd percentage
    USED_HDD_P=$(df -k 2>&1 | egrep "mmcblk0p2|mmcblk0p3|/dev/root" 2>&1 | awk '{ print $5 }' 2>&1)

    # total swap
    TOTAL_SWAP=$(cat /proc/meminfo 2>&1 | grep "SwapTotal" 2>&1 | awk '{ print $2 }' 2>&1)
    # used swap
    USED_SWAP=$(cat /proc/meminfo 2>&1 | grep "SwapCached" 2>&1 | awk '{ print $2 }' 2>&1)
    # calculate swap kilo bytes into mega bytes
    USED_SWAP_CALC=$(echo "${USED_SWAP:?}/1024" 2>&1 | bc 2>&1)
    TOTAL_SWAP_CALC=$(echo "${TOTAL_SWAP:?}/1024" 2>&1 | bc 2>&1)

    if [[ ! -f "${LOG_DIR:?}"/node_data/stats/ifconfig ]] &>/dev/null; then
      # save ifconfig values to ifconfig, do this once
      ifconfig 2>&1 | egrep -A8 "wlan[0-9]+|eth[0-9]+" >"${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1
    fi

    # get ip address from interface
    IP_ADDRESS=$(cat "${LOG_DIR:?}"/node_data/stats/ifconfig 2>/dev/null | egrep "inet " 2>&1 | grep -vwE "127.0.0.1" 2>&1 | awk '{ print $2 }' 2>&1)
    # get ip address (no color)
    IP_ADDRESS_N="${IP_ADDRESS:?}"

    # get wallet version
    WALLET_VERSION=$(cat "${LOG_DIR:?}"/node_data/client/version 2>/dev/null)
    # get wallet balance
    WALLET_BALANCE=$(cat "${LOG_DIR:?}"/node_data/stats/total_balance 2>/dev/null | awk '{ printf "%.2f\n", $1 }' 2>&1)

    # interface icon (top right)
    INTERFACE=$(egrep "wlan*|eth*" "${LOG_DIR:?}"/node_data/stats/ifconfig 2>&1 | grep -B1 "inet" 2>&1 | egrep -o "wlan[0-9]+|eth[0-9]+" 2>&1)

    # create "connected/working" ipv4/ipv6 peers list, sort, remove duplicates
    # note: only use addr, no port
    if [ -f "${LOG_DIR:?}"/node_data/client/getpeerinfo ] &>/dev/null; then
      # get clean ipv4 address, disregard non ipv4
      egrep -o '([0-9]{1,3}\.){3}[0-9]{1,3}' "${LOG_DIR:?}"/node_data/client/getpeerinfo 2>&1 | sort -n 2>&1 | awk '!a[$0]++' >"${LOG_DIR:?}"/success 2>&1
      # get clean ipv6 address, disregard non ipv6 and lines shorter than n
      egrep -o '([A-Fa-f0-9]{1,4}::?){1,7}[A-Fa-f0-9]{1,4}' "${LOG_DIR:?}"/node_data/client/getpeerinfo 2>&1 | sort -n 2>&1 | awk '!a[$0]++' 2>&1 | sed -r '/^.{,8}$/d' >>"${LOG_DIR:?}"/success 2>&1
      # get clean dns address, disregard non dns
      grep -oiE '([a-zA-Z0-9][a-zA-Z0-9-]{1,61}\.){1,}(\.?[a-zA-Z]{2,}){1,}' "${LOG_DIR:?}"/node_data/client/getpeerinfo 2>&1 | sort -n 2>&1 | awk '!a[$0]++' >>"${LOG_DIR:?}"/success 2>&1
      # remove duplicates, sort, disregard 127 address
      cat "${LOG_DIR:?}"/success 2>/dev/null | awk '!a[$0]++' 2>&1 | sort -n 2>&1 | grep -v "127." >"${LOG_DIR:?}"/node_data/peers/success 2>&1
      # remove old file
      rm "${LOG_DIR:?}"/success &>/dev/null
    fi
    # unique connections
    UNIQP2P=$(wc -l "${LOG_DIR:?}"/node_data/peers/success 2>&1 | awk '{ print $1 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)

    # get blockchain sync
    WALLET_SYNC=$(cat "${LOG_DIR:?}"/node_data/client/tmp/proc 2>/dev/null | sed 's/^0*//' 2>&1 | tr -d '.' 2>&1)

    if [[ -z "$WALLET_SYNC" ]] &>/dev/null; then
      WALLET_SYNC="1"
    fi
    WALLET_SYNC=$(echo "100/999990*${WALLET_SYNC:?}" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1)
    # if progress equals 1, then 100% synced
    if [[ $(grep -o "progress=1.00" "${LOG_DIR:?}"/node_data/synced 2>&1) ]] &>/dev/null; then
      WALLET_SYNC="OK" # wallet blockchain is synced 100%
    else
      WALLET_SYNC="${WALLET_SYNC:?}%" # wallet blockchain is synced 100%
    fi

    # get latest repository and date
    LATEST_HEAD=$(cd /home/"$(whoami)"/pi-node || exit && git rev-parse --short HEAD 2>&1 | grep -Eo '[a0-z9]{7}' 2>&1 | head -1 2>&1)
    LATEST_DATE=$(cd /home/"$(whoami)"/pi-node || exit && git log -1 --format="%at" | xargs -I{} date -d @{} '+%Y')

    # get wallet value
    WALLET_VALUE=$(echo "$(tail -1 "${LOG_DIR:?}"/node_data/stats/price 2>&1 | awk '{ printf "%.8f\n", $1 }' 2>&1)*$WALLET_BALANCE" 2>&1 | bc -l 2>&1 | awk '{ printf "%.2f\n", $1 }' 2>&1 | tail -1 2>&1)
    # get wallet inputs
    WALLET_INPUTS=$(grep "address" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | wc -l 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)

    # communication port
    COM=$(awk '{ print $3 }' "${LOG_DIR:?}"/node_data/com 2>/dev/null)

    if [[ -z "$COM" ]] &>/dev/null; then
      COM="Swap"
    fi

    # Thank you! -> https://stackoverflow.com/questions/59862020

    dot_field() {
      # todo: Change implementation when field can be 2 words with a space in between
      printf "%-17.17s" "$1" | tr ' ' ' '
      # The : must be printed in a second statement when you don't want cyan dots.
      printf ' '
    }
    # todo: Change implementation when field can be 2 words with a space in between
    space_number() {
      printf "%-18.18s" "$1"
    }
    # todo: add logic when only 4 parameters are given
    printline() {
      echo "   $(dot_field "$1") $(space_number "$2")$(dot_field "$3") $(space_number "$4")$(dot_field "$5") $(space_number "$6")"
    }

    display_result() {
      dialog --title "$1" \
        --no-collapse \
        --msgbox "$RESULT" 0 0
    }

    RESULT=$(
      echo
      printline "System" "$(uname -o 2>&1)" "Kernel" "$(uname -r 2>&1)" "Hardware" "$(cat /proc/device-tree/model 2>/dev/null | tr -d '\0' 2>&1 | awk '{ print $1,$2,$3 }' 2>&1)"
      printline "Load" "${LOAD:?}" "System Uptime" "${SYS_UPTIME:?}" "Wallet Uptime" "${UPTIME:?}"
      echo
      printline "Free/Memory" "${FREE_MEM_RR:?}M/${TOTAL_MEM_RR:?}M" "CPU Temperature" "${CPU_CTEMP:?} C ${CPU_FTEMP:?} F (${CPUS:?})" "Address" "${IP_ADDRESS_N:?}"
      printline "Used/Swap" "${USED_SWAP_CALC:?}M/${TOTAL_SWAP_CALC:?}M" "CPU Speed" "$(cat "$LOG_DIR"/node_data/stats/cpuspeed 2>/dev/null) MHz" "Network" "${WALLET_CHAIN:?} ${INTERFACE:?}"
      printline "User Space" "$(du -sh /home/* 2>/dev/null | xargs 2>&1 | awk '{ print $1,$2 }' 2>&1)" "Users" "${USER:?} ($(users 2>&1 | awk '{ print $1 }' 2>&1))" "Upload" "${UPLOAD:?}"
      printline "Used HDD" "${USED_HDD:?} ${USED_HDD_P:?}" "COM" "$COM" "Download" "${DOWNLOAD:?}"
      echo
      printline "Wallet" "${WALLET_VERSION:?}" "Headers/Blocks" "${WALLET_HEADS:?}/${WALLET_BLOCK:?}" "Repository" "${LATEST_HEAD:?} - ${LATEST_DATE:?}"
      printline "PID" "${PID_DAEMON:?}" "Connections" "${WALLET_PEERS_TOTAL:?} Unique ${UNIQP2P:?}" "Staking Status" "${NODE_PROOF:?}"
      printline "Wallet Size" "$(du -sh "${WALLET_DIR:?}" | awk '{ print $1 }' 2>&1) ${WALLET_SYNC:?}" "Failed/Success" "$(wc -l "${LOG_DIR:?}"/node_data/peers/failed 2>&1 | awk '{ print $1 }' 2>&1)/$(wc -l "${LOG_DIR:?}"/node_data/peers/success 2>&1 | awk '{ print $1 }' 2>&1)" "Coin Supply" "${NODE_COIN_SUPPLY:?}"
      printline "Backups Size" "$(du -sh "${WALLET_DIR:?}"/backups 2>&1 | awk '{ print $1 }' 2>&1)" "Add/Saved" "$(wc -l "${LOG_DIR:?}"/node_data/add_peers 2>&1 | awk '{ print $1 }' 2>&1)/$(wc -l "${WALLET_DIR:?}"/addnodes 2>&1 | awk '{ print $1 }' 2>&1)" "Wallet Balance" "${WALLET_BALANCE:?} (${WALLET_INPUTS:?})"
      printline "wallet.dat" "$(du -sh "${WALLET_DIR:?}"/wallet.dat 2>&1 | awk '{ print $1 }' 2>&1)" "Bans" "${WALLET_PEERS_BANNED:?}" "Wallet Value" "${WALLET_VALUE:?} USD"
      echo
    )
    display_result "System Information"
    clear
  else
    printf '%b' "[${R1:?}!!${N0:?}] Daemon not running!\n"
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo
  fi

  ;;

"6")

  if [ -x "$(command -v ncdu)" ] &>/dev/null; then
    ncdu -v
  fi
  read -r -p "[YN] Analyze the entire system with (ncdu)? y/n " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
    if ! [ -x "$(command -v ncdu)" ] &>/dev/null; then
      sudo apt-get install ncdu -y
    fi
    sudo ncdu /
  fi

  display_result() {
    dialog --title "$1" \
      --no-collapse \
      --msgbox "$RESULT" 0 0
  }

  RESULT=$(df -h)
  display_result "Disk Space"
  clear

  ;;

"4")

  HEIGHT=12
  WIDTH=68
  CHOICE_HEIGHT=5
  BACKTITLE="Download, Install & Compile"
  TITLE="Download wallets, bootstrap, drivers, compiler"
  MENU="Choose one option:"

  OPTIONS=(1 "Download         Download a specific wallet manually"
    2 "Download         Download wallet, bootstrap automatically"
    3 "Bootstrap        Download and Install bootstrap"
    4 "Display          Setup display (HyperPixel4) drivers"
    5 "Compiler         Compile new wallet")

  CHOICE=$(dialog --clear \
    --backtitle "$BACKTITLE" \
    --title "$TITLE" \
    --menu "$MENU" \
    $HEIGHT $WIDTH $CHOICE_HEIGHT \
    "${OPTIONS[@]}" \
    2>&1 >/dev/tty)

  clear
  case $CHOICE in

  # download manually

  "1")

    # create uname -a
    uname -a >"${LOG_DIR:?}"/node_data/uname

    # get latest release
    LATEST_VERSION=$(curl -s "${WALLET_RELEASE:?}" 2>&1 | grep -Po "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" 2>&1)

    function setup_zip() {
      read -r -p "[YN] Install new wallet? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

        # old wallets
        mkdir /home/"$(whoami)"/Wallet.old &>/dev/null
        # wallet directory
        mkdir /home/"$(whoami)"/Wallet &>/dev/null

        if cat "${LOG_DIR:?}"/node_data/uname 2>/dev/null | grep "armv7l" &>/dev/null; then
          UNAME_SYSTEM="armv7l"
          UNAME_FILE="${WALLET_NAME:?}.arm-linux-gnueabihf.zip"
        fi
        if cat "${LOG_DIR:?}"/node_data/uname 2>/dev/null | grep "aarch64" &>/dev/null; then
          UNAME_SYSTEM="aarch64"
          UNAME_FILE="${WALLET_NAME:?}.aarch64-linux-gnu.zip"
        fi
        if cat "${LOG_DIR:?}"/node_data/uname 2>/dev/null | grep "x86_64" &>/dev/null; then
          UNAME_SYSTEM="x86_64"
          UNAME_FILE="${WALLET_NAME:?}.Linux.zip"
        fi

        read -r -p "[YN] Different system? y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
          UNAME_FILE="${UNAME_SYSTEM:?}"
        fi

        # setup node wallet
        cp /home/"$(whoami)"/"${UNAME_FILE:?}" /home/"$(whoami)"/Wallet.old/"${LATEST_VERSION:?}"_"${UNAME_SYSTEM:?}".zip 2>&1
        yes "A" 2>&1 | unzip -j /home/"$(whoami)"/Wallet.old/"${LATEST_VERSION:?}"_"${UNAME_SYSTEM:?}".zip -d /home/"$(whoami)"/Wallet/ 2>&1
      fi
    }

    HEIGHT=16
    WIDTH=42
    CHOICE_HEIGHT=9
    BACKTITLE="Download manually"
    TITLE="Download Menu"
    MENU="Choose one option:"

    OPTIONS=(1 "libs.zip"
      2 "Wallet.aarch64-linux-gnu.zip"
      3 "Wallet.arm-linux-gnueabihf.zip"
      4 "Wallet.Linux.zip"
      5 "Wallet.Mac.dmg"
      6 "Wallet.Mac.zip"
      7 "Wallet.Ubuntu16.zip"
      8 "Source code (zip)"
      9 "Source code (tar.gz)")

    CHOICE=$(dialog --clear \
      --backtitle "$BACKTITLE" \
      --title "$TITLE" \
      --menu "$MENU" \
      $HEIGHT $WIDTH $CHOICE_HEIGHT \
      "${OPTIONS[@]}" \
      2>&1 >/dev/tty)

    clear
    case $CHOICE in

    "1")

      printf '%b' "[${GR:?}Ok${N0:?}] Downloading libs.zip${N0:?}\n"
      URL="${WALLET_DOWNLOAD:?}/${LATEST_VERSION:?}"
      cd || exit && wget -c "${URL:?}"/libs.zip
      UNAME_SYSTEM="libs.zip"
      echo
      read -r -p "[Ok] ${UNAME_SYSTEM:?} downloaded! Press Enter to continue" </dev/tty
      echo

      ;;

    "2")

      printf '%b' "[${GR:?}Ok${N0:?}] Downloading Wallet.aarch64-linux-gnu.zip${N0:?}\n"
      URL="${WALLET_DOWNLOAD:?}/${LATEST_VERSION:?}"
      cd || exit && wget -c "${URL:?}"/"${WALLET_NAME:?}".aarch64-linux-gnu.zip
      UNAME_SYSTEM="${WALLET_NAME:?}.aarch64-linux-gnu.zip"
      setup_zip

      ;;

    "3")

      printf '%b' "[${GR:?}Ok${N0:?}] Downloading Wallet.arm-linux-gnueabihf.zip${N0:?}\n"
      URL="${WALLET_DOWNLOAD:?}/${LATEST_VERSION:?}"
      cd || exit && wget -c "${URL:?}"/"${WALLET_NAME:?}".arm-linux-gnueabihf.zip
      UNAME_SYSTEM="${WALLET_NAME:?}.arm-linux-gnueabihf.zip"
      setup_zip

      ;;

    "4")

      printf '%b' "[${GR:?}Ok${N0:?}] Downloading Wallet.Linux.zip${N0:?}\n"
      URL="${WALLET_DOWNLOAD:?}/${LATEST_VERSION:?}"
      cd || exit && wget -c "${URL:?}"/"${WALLET_NAME:?}".Linux.zip
      UNAME_SYSTEM="${WALLET_NAME:?}.Linux.zip"
      setup_zip

      ;;

    "5")

      printf '%b' "[${GR:?}Ok${N0:?}] Downloading Wallet.Mac.dmg${N0:?}\n"
      URL="${WALLET_DOWNLOAD:?}/${LATEST_VERSION:?}"
      cd || exit && wget -c "${URL:?}"/"${WALLET_NAME:?}".Mac.dmg
      UNAME_SYSTEM="${WALLET_NAME:?}.Mac.dmg"
      echo
      read -r -p "[Ok] ${UNAME_SYSTEM:?} downloaded! Press Enter to continue" </dev/tty
      echo

      ;;

    "6")

      printf '%b' "[${GR:?}Ok${N0:?}] Downloading Wallet.Mac.zip${N0:?}\n"
      URL="${WALLET_DOWNLOAD:?}/${LATEST_VERSION:?}"
      cd || exit && wget -c "${URL:?}"/"${WALLET_NAME:?}".Mac.zip
      UNAME_SYSTEM="${WALLET_NAME:?}.Mac.zip"
      echo
      read -r -p "[Ok] ${UNAME_SYSTEM:?} downloaded! Press Enter to continue" </dev/tty
      echo

      ;;

    "7")

      printf '%b' "[${GR:?}Ok${N0:?}] Downloading Wallet.Ubuntu16.zip${N0:?}\n"
      URL="${WALLET_DOWNLOAD:?}/${LATEST_VERSION:?}"
      cd || exit && wget -c "${URL:?}"/"${WALLET_NAME:?}".Ubuntu16.zip
      UNAME_SYSTEM="${WALLET_NAME:?}.Ubuntu16.zip"
      setup_zip

      ;;

    "8")

      printf '%b' "[${GR:?}Ok${N0:?}] Downloading Source code (zip)${N0:?}\n"
      URL="${WALLET_SOURCE:?}/${LATEST_VERSION:?}"
      cd || exit && wget -c "${URL:?}"/"${LATEST_VERSION:?}".zip
      UNAME_SYSTEM="${LATEST_VERSION:?}.zip"
      echo
      read -r -p "[Ok] ${UNAME_SYSTEM:?} downloaded! Press Enter to continue" </dev/tty
      echo

      ;;

    "9")

      printf '%b' "[${GR:?}Ok${N0:?}] Downloading Source code (tar.gz)${N0:?}\n"
      URL="${WALLET_SOURCE:?}/${LATEST_VERSION:?}"
      cd || exit && wget -c "${URL:?}"/"${LATEST_VERSION:?}".tar.gz
      UNAME_SYSTEM="${LATEST_VERSION:?}.tar.gz"
      echo
      read -r -p "[Ok] ${UNAME_SYSTEM:?} downloaded! Press Enter to continue" </dev/tty
      echo

      ;;

    esac

    ;;

    # install wallet & bootstrap automatically

  "2")

    # get latest release
    LATEST_VERSION=$(curl -s "${WALLET_RELEASE:?}" 2>&1 | grep -Po "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" 2>&1)
    # get wallet version
    WALLET_VERSION=$(cat "${LOG_DIR:?}"/node_data/client/version 2>/dev/null)

    if [[ -z "$WALLET_VERSION" ]] &>/dev/null; then
      # non responsive
      WALLET_VERSION="${GR:?}vLoading${N0:?}"
    fi

    printf '%b' "Latest....: ${G0:?}v${LATEST_VERSION:?}${N0:?}\n"
    printf '%b' "Installed.: ${G1:?}${WALLET_VERSION:?}${N0:?}\n"
    echo
    read -r -p "[YN] Install automatically? y/n " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

      mkdir /home/"$(whoami)"/Wallet.old &>/dev/null
      mkdir /home/"$(whoami)"/Wallet &>/dev/null

      function bootstrap() {
        printf '%b' "[${R1:?}!!${N0:?}] Downloading bootstrap.zip!\n"
        # get latest release
        LATEST_VERSION=$(curl -s "${WALLET_RELEASE:?}" 2>&1 | grep -Po "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" 2>&1)
        cd || exit && wget -c "${WALLET_DOWNLOAD:?}"/"${LATEST_VERSION:?}"/"${WALLET_NAME:?}".bootstrap.zip
        read -r -p "[YN] Unzip bootstrap.zip? -> (${WALLET_DIR:?}) y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

          printf '%b' "[${R1:?}!!${N0:?}] "
          "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" stop && sleep 5
          # wait on node (daemon) to stop
          until pidof "${WALLET_DAEMON:?}" 2>&1 | wc -w 2>&1 | egrep "0" &>/dev/null; do
            clear
            printf '%b' "[${R1:?}!!${N0:?}] waiting on wallet (${G1:?}$(pidof "${WALLET_DAEMON:?}" 2>&1)${N0:?}) daemon to shutdown..\n"
            sleep 10
            kill -9 "$(pidof "${WALLET_DAEMON:?}" 2>&1)" &>/dev/null
          done
          printf '%b' "[${G1:?}!?${N0:?}] Extracting from bootstrap.zip!\n"
          yes "A" 2>&1 | unzip /home/"$(whoami)"/*bootstrap.zip -d "${WALLET_DIR:?}" 2>&1

          # create lock file
          echo "Bootstrap installed $(LC_ALL=de_US.utf8 date 2>&1)" >"${WALLET_DIR:?}"/boot
          read -r -p "[YN] Remove bootstrap.zip? y/n " -n 1 -r
          echo
          if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
            rm /home/"$(whoami)"/*.bootstrap.zip &>/dev/null
          else
            ls -lSh /home/"$(whoami)"/*.bootstrap.zip 2>&1
          fi
        fi
      }

      function setup() {
        if cat "${LOG_DIR:?}"/node_data/uname 2>/dev/null | egrep "armv7l" &>/dev/null; then
          UNAME_SYSTEM="armv7l"
          UNAME_FILE="${WALLET_NAME:?}.arm-linux-gnueabihf.zip"
        fi
        if cat "${LOG_DIR:?}"/node_data/uname 2>/dev/null | grep "aarch64" &>/dev/null; then
          UNAME_SYSTEM="aarch64"
          UNAME_FILE="${WALLET_NAME:?}.aarch64-linux-gnu.zip"
        fi
        if cat "${LOG_DIR:?}"/node_data/uname 2>/dev/null | grep "x86_64" &>/dev/null; then
          UNAME_SYSTEM="x86_64"
          UNAME_FILE="${WALLET_NAME:?}.Linux.zip"
        fi
      }

      if [[ -z "$UNAME_FILE" ]] &>/dev/null; then
        # non responsive
        UNAME_FILE=$(tr -dc 'a-z' </dev/urandom 2>&1 | head -c 8 2>&1 | rev 2>&1)
      fi
      if [[ -z "$UNAME_SYSTEM" ]] &>/dev/null; then
        # non responsive
        UNAME_SYSTEM=$(tr -dc 'a-z' </dev/urandom 2>&1 | head -c 8 2>&1 | rev 2>&1)
      fi

      function setup_zip() {
        read -r -p "[YN] Install new wallet? y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
          # setup wallet daemon
          cp /home/"$(whoami)"/"${UNAME_FILE:?}" /home/"$(whoami)"/Wallet.old/"${LATEST_VERSION:?}"_"${UNAME_SYSTEM:?}".zip
          yes "A" 2>&1 | unzip -j /home/"$(whoami)"/Wallet.old/"${LATEST_VERSION:?}"_"${UNAME_SYSTEM:?}".zip -d /home/"$(whoami)"/Wallet/
        fi
      }

      # armv7l
      if cat "${LOG_DIR:?}"/node_data/uname 2>/dev/null | egrep "armv7l" &>/dev/null; then
        printf '%b' "[${G1:?}Ok${N0:?}] armv7l System\n"
        if [[ ! -f /home/"$(whoami)"/"${WALLET_NAME:?}".arm-linux-gnueabihf.zip ]] &>/dev/null; then
          # download arm-linux-gnueabihf.zip
          cd || exit && wget -c "${WALLET_DOWNLOAD:?}"/"${LATEST_VERSION:?}"/"${WALLET_NAME:?}".arm-linux-gnueabihf.zip
        fi
      fi

      # aarch64
      if cat "${LOG_DIR:?}"/node_data/uname 2>/dev/null | grep "aarch64" &>/dev/null; then
        printf '%b' "[${G1:?}Ok${N0:?}] aarch64 System\n"
        if [[ ! -f /home/"$(whoami)"/"${WALLET_NAME:?}".aarch64-linux-gnu.zip ]] &>/dev/null; then
          # download $wallet_name.aarch64-linux-gnu.zip
          cd || exit && wget -c "${WALLET_DOWNLOAD:?}"/"${LATEST_VERSION:?}"/"${WALLET_NAME:?}".aarch64-linux-gnu.zip
        fi
      fi

      # x86_64
      if cat "${LOG_DIR:?}"/node_data/uname 2>/dev/null | grep "x86_64" &>/dev/null; then
        printf '%b' "[${G1:?}Ok${N0:?}] x86_64 System\n"
        if [[ ! -f /home/"$(whoami)"/"${WALLET_NAME:?}".Linux.zip ]] &>/dev/null; then
          # download $wallet_name.linux.zip
          cd || exit && wget -c "${WALLET_DOWNLOAD:?}"/"${LATEST_VERSION:?}"/"${WALLET_NAME:?}".Linux.zip
        fi
      fi

      setup
      setup_zip
      bootstrap # install bootstrap

      echo
      read -r -p "[Ok] Wallet installed! Press Enter to continue" </dev/tty
      echo
    fi

    ;;

    # download/install bootstrap

  "3")

    printf '%b' "[${R1:?}!!${N0:?}] Downloading bootstrap.zip!\n"
    # get latest release
    LATEST_VERSION=$(curl -s "${WALLET_RELEASE:?}" 2>&1 | grep -Po "[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" 2>&1)
    cd || exit && wget -c "${WALLET_DOWNLOAD:?}"/"${LATEST_VERSION:?}"/"${WALLET_NAME:?}".bootstrap.zip
    read -r -p "[YN] Unzip bootstrap? -> (${WALLET_DIR:?}) y/n " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

      printf '%b' "[${R1:?}!!${N0:?}] "
      "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" stop && sleep 5
      # wait on node (daemon) to stop
      until pidof "${WALLET_DAEMON:?}" 2>&1 | wc -w 2>&1 | egrep "0" &>/dev/null; do
        clear
        printf '%b' "[${R1:?}!!${N0:?}] waiting on wallet (${G1:?}$(pidof "${WALLET_DAEMON:?}" 2>&1)${N0:?}) daemon to shutdown..\n"
        sleep 10
        kill -9 "$(pidof "${WALLET_DAEMON:?}" 2>&1)" &>/dev/null
      done
      printf '%b' "[${G1:?}!?${N0:?}] Extracting from bootstrap.zip!\n"
      yes "A" 2>&1 | unzip /home/"$(whoami)"/*bootstrap.zip -d "${WALLET_DIR:?}" 2>&1
      echo
      read -r -p "[Ok] Bootstrap installed! Press Enter to continue" </dev/tty
      echo
    fi

    ;;

    # setup display (hyperpixel4)

  "4")

    HEIGHT=13
    WIDTH=51
    CHOICE_HEIGHT=6
    BACKTITLE="Setup display"
    TITLE="HyperPixel4 Menu"
    MENU="Choose one option:"

    OPTIONS=(1 "Setup            Install drivers"
      2 "Right            Rotate display right"
      3 "Left             Rotate display left"
      4 "Normal           Rotate display normal"
      5 "Inverted         Rotate display inverted"
      6 "Report           Debug hyperpixel4")

    CHOICE=$(dialog --clear \
      --backtitle "$BACKTITLE" \
      --title "$TITLE" \
      --menu "$MENU" \
      $HEIGHT $WIDTH $CHOICE_HEIGHT \
      "${OPTIONS[@]}" \
      2>&1 >/dev/tty)

    clear
    case $CHOICE in

    # install display

    "1")

      # https://github.com/pimoroni/hyperpixel4

      read -r -p "[YN] Install HyperPixel4? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
        cd || exit && curl -sSL https://get.pimoroni.com/hyperpixel4 2>&1 | bash 2>&1
        echo
        read -r -p "[Ok] HyperPixel4 installed! Press Enter to continue" </dev/tty
        echo
        read -r -p "[YN] Reboot system? y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
          sudo reboot
        fi
      fi

      ;;

      # rotate display right

    "2")

      printf '%b' "${G1:?}Rotating display to the right${N0:?}!\n"
      hyperpixel4-rotate right 2>&1
      echo
      read -r -p "[Ok] Press Enter to continue" </dev/tty
      echo
      read -r -p "[YN] Reboot system? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
        sudo reboot
      fi

      ;;

      # rotate display left

    "3")

      printf '%b' "${G1:?}Rotating display to the left${N0:?}!\n"
      hyperpixel4-rotate left 2>&1
      echo
      read -r -p "[Ok] Press Enter to continue" </dev/tty
      echo
      read -r -p "[YN] Reboot system? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
        sudo reboot
      fi

      ;;

      # rotate display normal

    "4")

      printf '%b' "${G1:?}Rotating display normal${N0:?}!\n"
      hyperpixel4-rotate normal 2>&1
      echo
      read -r -p "[Ok] Press Enter to continue" </dev/tty
      echo
      read -r -p "[YN] Reboot system? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
        sudo reboot
      fi

      ;;

      # rotate display Inverted

    "5")

      printf '%b' "${G1:?}Rotating display inverted${N0:?}!\n"
      hyperpixel4-rotate inverted 2>&1
      echo
      read -r -p "[Ok] Press Enter to continue" </dev/tty
      echo
      read -r -p "[YN] Reboot system? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
        sudo reboot
      fi

      ;;

      # debug hyperpixel4 - troubleshooting

    "6")

      # make sure i2cdetect is installed
      if ! [ -x "$(command -v i2cdetect)" ] &>/dev/null; then
        sudo apt-get install i2c-tools -y
      fi

      printf '%b' "${Y1:?}Debug hyperpixel4${N0:?}!\n"
      curl -sSL https://raw.githubusercontent.com/pimoroni/hyperpixel4/master/hyperpixel4-debug.sh 2>&1 | bash >"${LOG_DIR:?}"/debug 2>&1
      sleep 1
      printf '%b' "Then ${CY:?}file a bug report${N0:?}.\n"
      echo "Saved at -> ${LOG_DIR:?}/debug."
      printf '%b' "${GR:?}https://github.com/pimoroni/hyperpixel4/issues/new/choose${N0:?}\n"
      echo
      read -r -p "[Ok] Press Enter to continue" </dev/tty
      echo

      ;;

    esac

    ;;

    # compiler

  "5")

    echo
    read -r -p "[Ok] Nothing was built, press Enter to continue" </dev/tty
    echo

    ;;

  esac

  ;;

"5")

  HEIGHT=18
  WIDTH=48
  CHOICE_HEIGHT=11
  BACKTITLE="Node configuration"
  TITLE="Configuration & Tools"
  MENU="Choose one option:"

  OPTIONS=(1 "Wallet           Edit $(echo "${WALLET_CONFIG:?}" 2>&1 | awk -F. '{ print $1 }' 2>&1)"
  2 "Masternode       Masternode options"
  3 "PiNode           pinode.conf"
  4 "Config.txt       boot/config.txt"
  5 "Torrc            Tor configuration"
  6 "Crontab          Job scheduler"
  7 "Crontab (root)   Admin job scheduler"
  8 "Filesystem       /etc/fstab"
  9 "Graphs           rrdtool options"
  10 "Reset            Reset configs"
  11 "Backup           Zip backup files")

  CHOICE=$(dialog --clear \
    --backtitle "$BACKTITLE" \
    --title "$TITLE" \
    --menu "$MENU" \
    $HEIGHT $WIDTH $CHOICE_HEIGHT \
    "${OPTIONS[@]}" \
    2>&1 >/dev/tty)

  clear
  case $CHOICE in

  "1")

    printf '%b' "${GR:?}CTRL+O to save, CTRL+X to exit${N0:?}\n"
    read -t 1 -r -p "[Ok] Press Enter to continue" </dev/tty
    clear
    nano "${WALLET_DIR:?}"/"${WALLET_CONFIG:?}"

    ;;

  "2")

    HEIGHT=11
    WIDTH=56
    CHOICE_HEIGHT=4
    BACKTITLE="Masternode menu"
    TITLE="Masternode Options"
    MENU="Choose one option:"

    OPTIONS=(1 "Install          Setup Masternode"
      2 "Config           Edit $(echo "${WALLET_MASTER:?}" 2>&1 | awk -F. '{ print $1 }' 2>&1)"
      3 "Status           Masternode information"
      4 "Locked           Locked Masternode collateral")

    CHOICE=$(dialog --clear \
      --backtitle "$BACKTITLE" \
      --title "$TITLE" \
      --menu "$MENU" \
      $HEIGHT $WIDTH $CHOICE_HEIGHT \
      "${OPTIONS[@]}" \
      2>&1 >/dev/tty)

    clear
    case $CHOICE in

    "1")

      if [[ "$(grep "successfully started" "${WALLET_DIR:?}"/masternode_status 2>&1)" ]] &>/dev/null; then
        # already setup and running
        echo
        printf '%b' "[${G1:?}!?${N0:?}] Already setup and running!\n"
        read -r -p "[!!] Press Enter to continue!" </dev/tty
        clear
      fi

      if [[ "$(cat "${LOG_DIR:?}"/node_data/client/getwalletinfo 2>&1 | grep "autocombine_enabled" 2>&1 | grep -o "true" 2>&1)" ]] &>/dev/null; then
        read -r -p "[YN] You should turn off auto combine & stake split !? y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
          # disable setautocombinethreshold & setstakesplitthreshold
          "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" setautocombinethreshold false
          "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" setstakesplitthreshold 0
        fi
      fi

      # get wallet port, do this once
      if [[ ! -f "${WALLET_DIR:?}"/wallet_port ]] &>/dev/null; then
        printf '%b' "[??] Enter wallet Port ${G1:?}> ${N0:?}"
        read -r PORT
        echo "${PORT:?}" >"${WALLET_DIR:?}"/wallet_port 2>&1
        if [[ -z "$PORT" ]] &>/dev/null; then
          # empty, exit
          printf '%b' "[${R1:?}!!${N0:?}] Empty, try again\n"
          exit
        fi
      else
        PORT="$(cat "${WALLET_DIR:?}"/wallet_port 2>/dev/null)"
      fi

      printf '%b' "[${R1:?}!!${N0:?}] ${R1:?}Warning:${GR:?} This will use all available coins in wallet!${N0:?}\n"
      read -r -p "[Ok] Press Enter to continue" </dev/tty
      clear

      if [[ ! -f "${WALLET_DIR:?}"/masternode_collateral ]]; then
        echo "Enter masternode collateral"
        read -r MASTERNODECO
        echo
        echo "${MASTERNODECO:?}" >"${WALLET_DIR:?}"/masternode_collateral
        if [[ -z "$MASTERNODECO" ]] &>/dev/null; then
          echo "empty!"
          exit
        fi
      fi
      MASTERNODECO="$(cat "${WALLET_DIR:?}"/masternode_collateral 2>/dev/null)" # masternode collateral

      if [[ ! -f "${WALLET_DIR:?}"/masternode_address ]] &>/dev/null; then
        read -r -p "[YN] Create new masternode address? y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
          # old guide - trumpcoin patriotnode -> https://github.com/trumpcoinsupport/TrumpCoin/wiki/Windows-Linux-Mac-Patriotnode-Setup-Guide
          # in the console window enter getnewaddress MN and copy the result.
          "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" getnewaddress MN >"${WALLET_DIR:?}"/masternode_address
        fi
      else
        MASTERNODE_ADDRESS=$(cat "${WALLET_DIR:?}"/masternode_address 2>/dev/null)
        printf '%b' "[${G1:?}Ok${N0:?}] ${CY:?}${MASTERNODE_ADDRESS:?}${N0:?} MN\n"
      fi

      if [[ ! -f "${WALLET_DIR:?}"/masternode_address ]] &>/dev/null; then
        printf '%b' "[${R1:?}!!${N0:?}] No masternode ${CY:?}address${N0:?} found!\n"
        sleep 1
      else

        # keep masternode status updated
        cp "${WALLET_DIR:?}"/masternode_status "${LOG_DIR:?}"/node_data/client/getpatriotnodestatus &>/dev/null

        # get useable wallet balance
        WALLET_BALANCE=$(grep "amount:" "${LOG_DIR:?}"/node_data/client/listunspent 2>&1 | awk '{ print $2 }' 2>&1 | awk '{ SUM += $1} END { print SUM }' 2>&1 | awk -F. '{ print $1 }' 2>&1)
        # get masternode address balance
        MASTER_BALANCE=$(echo "$(grep -c "txhash" "${WALLET_DIR:?}"/masternode_status 2>&1)*${MASTERNODECO:?}" 2>&1 | bc -l 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)

        if [[ -z "$WALLET_BALANCE" ]] &>/dev/null; then
          # non responsive
          WALLET_BALANCE="0"
        fi
        if [[ -z "$MASTER_BALANCE" ]] &>/dev/null; then
          # non responsive
          MASTER_BALANCE="0"
        fi

        if [[ ! "$MASTER_BALANCE" -eq "$MASTERNODECO" ]] &>/dev/null; then
          if [[ "$WALLET_BALANCE" -gt "$MASTERNODECO" ]] &>/dev/null; then
            if [[ -f "${WALLET_DIR:?}"/masternode_address ]] &>/dev/null; then
              read -r -p "[YN] Send ${MASTERNODECO:?} coins to ${MASTERNODE_ADDRESS:?}? y/n " -n 1 -r
              echo
              if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
                # this is your PATRIOTNODE DEPOSIT ADDRESS, where you will deposit ${masternodeco:?} coins to create a patriotnode
                "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" sendtoaddress "${MASTERNODE_ADDRESS:?}" "${MASTERNODECO:?}"
              fi
            fi
          else
            WALLET_MISSNG="$(echo "${MASTERNODECO:?}-${WALLET_BALANCE:?}" 2>&1 | bc -l 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)"
            printf '%b' "[${Y1:?}!!${N0:?}] Wallet has not enough coins ${G1:?}+${WALLET_BALANCE:?}${N0:?}, missing ${GR:?}-${WALLET_MISSNG:?}${N0:?}\n"
            read -r -p "[Ok] Press Enter to exit" </dev/tty
            exit
          fi
        else
          printf '%b' "[${G1:?}Ok${N0:?}] Masternode ${CY:?}address${N0:?} has enough coins.\n"
        fi

        if [[ ! -f "${WALLET_DIR:?}"/masternode_key ]] &>/dev/null; then
          read -r -p "[YN] Create new masternode key? y/n " -n 1 -r
          echo
          if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
            # in the fonsole debug window enter createpatriotnodekey - this is your PATRIOTNODE PRIVKEY.
            "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" createpatriotnodekey >"${WALLET_DIR:?}"/masternode_key
          fi
        else
          printf '%b' "[${G1:?}Ok${N0:?}] ${CY:?}$(cat "${WALLET_DIR:?}"/masternode_key 2>/dev/null)${N0:?} Key\n"
        fi

        MASTERNODE_KEY="$(cat "${WALLET_DIR:?}"/masternode_key 2>/dev/null)"

        # create tor_wan script
        echo "curl -s https://api.myip.com >${WALLET_DIR:?}/tor_wan 2>&1" >"${LOG_DIR:?}"/wan_curl 2>&1
        # get onion wan address (torify bash)
        torify bash "${LOG_DIR:?}"/wan_curl && rm "${LOG_DIR:?}"/wan_curl 2>&1

        read -r -p "[YN] Create new wallet configuration (overwriting)? y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

          # create random rpcuser & rpcpassword
          RANDOM_RPCL=$(tr -dc 'a-z' </dev/urandom 2>&1 | head -c 4 2>&1 | rev 2>&1)
          RANDOM_RPCN=$(echo "$RANDOM_RPCL" 2>&1 | rev 2>&1)

          # wallet configuration file (overwriting old configuration)
          echo "## ${WALLET_NAME:?} configuration file.
# Network-related settings:

# Run on the test network instead of the real ${WALLET_NAME:?} network.
#testnet=1

# RPC credentials
rpcuser=${RANDOM_RPCL:?}${RANDOM_RPCN:?}
rpcpassword=${RANDOM_RPCN:?}${RANDOM_RPCL:?}
rpcallowip=${RPC_IP:?}
rpcbind=${RPC_IP:?}
server=1

# masternode
patriotnode=1

patriotnodeaddr=$(cat "${WALLET_DIR:?}"/tor_wan 2>/dev/null | egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1):${PORT:?}

# masternode private key
patriotnodeprivkey=${MASTERNODE_KEY:?}

# get onion address
listenonion=1

# external ip address
externalip=$(cat "${WALLET_DIR:?}"/tor_wan 2>/dev/null | egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1)

# Connect via a SOCKS5 proxy (default: 127.0.0.1:9050)
proxy=${PROXY:?}

# Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: -proxy)
onion=${PROXY:?}

# Tor control port to use if onion listening enabled (default: 127.0.0.1:9051)
torcontrol=${TOR_CONTROL:?}

# Maximum number of inbound+outbound connections. (default: 125)

maxconnections=${MAX_P2P:?}" >"${LOG_DIR:?}"/wallet.conf.tmp 2>&1

          echo
          # output config data
          cat "${LOG_DIR:?}"/wallet.conf.tmp 2>&1
          echo
          read -r -p "[YN] Save new configuration? y/n " -n 1 -r
          echo
          if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
            mv "${LOG_DIR:?}"/wallet.conf.tmp "${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" &>/dev/null
          fi
        fi

        read -t 2 -r -p "[YN] Get masternode outputs? y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
          rm "${WALLET_DIR:?}"/masternode_outputs &>/dev/null
        fi

        if [[ ! -f "${WALLET_DIR:?}"/masternode_outputs ]] &>/dev/null; then
          # in the console debug window enter getpatriotnodeoutputs these are your PATRIOTNODE OUTPUT txhash and outputidx.
          "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" getpatriotnodeoutputs >"${WALLET_DIR:?}"/masternode_outputs
        else
          WALLET_TXHASH=$(cat "${WALLET_DIR:?}"/masternode_outputs 2>/dev/null | grep "txhash" 2>&1 | awk '{ print $2 }' 2>&1 | tr -d '"|,' 2>&1)
          OUTPUT_IDX=$(cat "${WALLET_DIR:?}"/masternode_outputs 2>/dev/null | grep "outputidx" 2>&1 | awk '{ print $2 }' 2>&1 | tr -d '"|,' 2>&1)
          printf '%b' "[${G1:?}Ok${N0:?}] txhash ${CY:?}$WALLET_TXHASH${N0:?}\n"
          printf '%b' "[${G1:?}Ok${N0:?}] outputidx ${CY:?}$OUTPUT_IDX${N0:?}\n"
        fi

        if [[ ! -f "${WALLET_DIR:?}"/"${WALLET_MASTER:?}" ]] &>/dev/null; then
          read -r -p "[YN] Create new patriotnode configuration (overwriting)? y/n " -n 1 -r
          echo
          if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
            read -r -p "[YN] Save new configuration? y/n " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
              # patriotnodename yourpublicip:${port:?} yourprivatekeygeneratedearlier txhash outputidx and replace patriotname, yourpublicip, yourprivatekeygeneratedearlier, txhash and outputidx.
              echo "MN $(cat "${WALLET_DIR:?}"/tor_wan 2>/dev/null | egrep -o "[0-9]+.[0-9]+.[0-9]+.[0-9]+" 2>&1):${PORT:?} ${MASTERNODE_KEY:?} ${WALLET_TXHASH:?} ${OUTPUT_IDX:?}" >>"${WALLET_DIR:?}"/"${WALLET_MASTER:?}"
            fi
          fi
        fi

        # restart wallet
        read -r -p "[YN] Re/start node (daemon)? y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

          # stop wallet daemon
          printf '%b' "[${R1:?}!!${N0:?}] $("${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" stop && sleep 5)\n"
          killall "${WALLET_DAEMON:?}" &>/dev/null
          printf '%b' "[${G1:?}Ok${N0:?}] Re/Starting node!\n"

          # make sure debug.log exist
          touch "${WALLET_LOG_DIR:?}"/debug.log 2>&1
          # remove old files
          rm "${LOG_DIR:?}"/node_data/synced &>/dev/null
          rm "${WALLET_DIR:?}"/onion &>/dev/null
          rm "${WALLET_DIR:?}"/getwan &>/dev/null

          truncate -s 0 "${WALLET_LOG_DIR:?}"/debug.log &>/dev/null
          sleep 1
          # start node (daemon)
          printf '%b' "[${G1:?}Ok${N0:?}] "
          "${WALLET_DIR:?}"/"${WALLET_DAEMON:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" -debug=tor -proxy="${PROXY:?}" -daemon
          printf '%b' "${LOG_DATE:?} Status() Wallet.Warden: PID(?) Starting wallet daemon!${N0:?}\n" >>"${WALLET_LOG_DIR:?}"/debug.log 2>&1
        fi
        read -r -p "[Ok] Press Enter to continue" </dev/tty
        echo
      fi

      ;;

    "2")

      printf '%b' "${GR:?}CTRL+O to save, CTRL+X to exit${N0:?}\n"
      read -t 1 -r -p "[Ok] Press Enter to continue" </dev/tty
      clear
      nano "${WALLET_DIR:?}"/"${WALLET_MASTER:?}"

      ;;

    "3")

      if [[ -s "${LOG_DIR:?}"/node_data/client/getpatriotnodestatus ]] &>/dev/null; then

        # greater than n seconds, continue
        if [[ "$(cat "${LOG_DIR:?}"/node_data/uptime 2>/dev/null)" -gt "1" ]] &>/dev/null; then

          "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" getpatriotnodestatus >"${WALLET_DIR:?}"/masternode_status 2>/dev/null
          # keep masternode status updated
          cp "${WALLET_DIR:?}"/masternode_status "${LOG_DIR:?}"/node_data/client/getpatriotnodestatus &>/dev/null

          display_result() {
            dialog --title " TXHash $(grep "txhash" "${LOG_DIR:?}"/node_data/client/getpatriotnodestatus 2>&1 | tr -d ',|"' 2>&1 | awk '{ print $2 }' 2>&1)" \
              --no-collapse \
              --msgbox "$RESULT" 0 0
          }

          RESULT=$(
            printf '%b' "Address $(grep "addr" "${LOG_DIR:?}"/node_data/client/getpatriotnodestatus 2>&1 | grep -v "netaddr" 2>&1 | awk '{ print $2 }' 2>&1 | tr -d ',|"' 2>&1)
Message $(grep "message" "${LOG_DIR:?}"/node_data/client/getpatriotnodestatus 2>&1 | tr -d ',|"' 2>&1 | awk '{ print $2,$3,$4 }' 2>&1)
Address $(grep "netaddr" "${LOG_DIR:?}"/node_data/client/getpatriotnodestatus 2>&1 | tr -d ',|"' 2>&1 | awk '{ print $2 }')
Updated $(ls -l "${WALLET_DIR:?}"/masternode_status 2>&1 | awk '{ print $6,$7,$8 }' 2>&1 | tr -d '.' 2>&1)
Outputidx $(grep "outputidx" "${LOG_DIR:?}"/node_data/client/getpatriotnodestatus 2>&1 | tr -d ',|"' 2>&1 | awk '{ print $2 }' 2>&1)
Status $(grep "status" "${LOG_DIR:?}"/node_data/client/getpatriotnodestatus 2>&1 | tr -d ',|"' 2>&1 | awk '{ print $2 }' 2>&1)
Rewards $(wc -l "${LOG_DIR:?}"/node_data/stats/rewards 2>&1 | awk '{ print $1 }' 2>&1 | awk '{ printf "%.0f\n", $1 }' 2>&1)"
          )
          display_result "Masternode Status"
          clear
        else
          printf '%b' "[${R1:?}!!${N0:?}] Daemon not running!\n"
          read -r -p "[Ok] Press Enter to continue" </dev/tty
          echo
        fi
      else
        printf '%b' "[${R1:?}!!${N0:?}] This is not a masternode!\n"
        read -r -p "[Ok] Press Enter to continue" </dev/tty
        echo
      fi

      ;;

    "4")

      MASTERNODECO="$(cat "${WALLET_DIR:?}"/masternode_collateral 2>/dev/null)" # masternode collateral

      display_result() {
        dialog --title " Count $(egrep -c "[aA0-zZ9]+" "${WALLET_DIR:?}"/masternode_lock 2>&1) Collateral $(echo "$(egrep -c "[aA0-zZ9]+" "${WALLET_DIR:?}"/masternode_lock 2>&1)*${MASTERNODECO:?}" 2>&1 | bc -l 2>&1 | awk -F. '{ print $1 }' 2>&1)" \
          --no-collapse \
          --msgbox "$RESULT" 0 0
      }

      RESULT=$(printf '%b' "$(cat "$WALLET_DIR"/masternode_lock 2>/dev/null)\n")
      display_result "Lock Status"
      clear

      ;;

    esac

    ;;

  "3")

    printf '%b' "${GR:?}CTRL+O to save, CTRL+X to exit${N0:?}\n"
    read -t 1 -r -p "[Ok] Press Enter to continue" </dev/tty
    clear
    nano /usr/local/bin/include/pinode.conf

    ;;

  "4")

    printf '%b' "${GR:?}CTRL+O to save, CTRL+X to exit${N0:?}\n"
    read -t 1 -r -p "[Ok] Press Enter to continue" </dev/tty
    clear
    sudo nano /boot/config.txt

    ;;

  "5")

    printf '%b' "${GR:?}CTRL+O to save, CTRL+X to exit${N0:?}\n"
    read -t 1 -r -p "[Ok] Press Enter to continue" </dev/tty
    clear
    sudo nano /etc/tor/torrc

    ;;

    # crontab

  "6")

    printf '%b' "${GR:?}CTRL+O to save, CTRL+X to exit${N0:?}\n"
    read -t 1 -r -p "[Ok] Press Enter to continue" </dev/tty
    clear
    crontab -e

    ;;

  "7")

    printf '%b' "${GR:?}CTRL+O to save, CTRL+X to exit${N0:?}\n"
    read -t 1 -r -p "[Ok] Press Enter to continue" </dev/tty
    clear
    sudo crontab -e

    ;;

    # edit fstab - filesystem table

  "8")

    printf '%b' "${GR:?}CTRL+O to save, CTRL+X to exit${N0:?}\n"
    read -t 1 -r -p "[Ok] Press Enter to continue" </dev/tty
    clear
    sudo nano /etc/fstab

    ;;

    # rrdtool options

  "9")

    HEIGHT=10
    WIDTH=45
    CHOICE_HEIGHT=3
    BACKTITLE="Graphs"
    TITLE="rrdtool (graphs) Options"
    MENU="Choose one option:"

    OPTIONS=(1 "Update           Update web graphs"
      2 "Databases        Data information"
      3 "Reset            Delete databases")

    CHOICE=$(dialog --clear \
      --backtitle "$BACKTITLE" \
      --title "$TITLE" \
      --menu "$MENU" \
      $HEIGHT $WIDTH $CHOICE_HEIGHT \
      "${OPTIONS[@]}" \
      2>&1 >/dev/tty)

    clear
    case $CHOICE in

    "1")

      if [[ "$GRAPH_STATS" -eq "1" ]] &>/dev/null; then
        read -r -p "[YN] Update graphs? y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
          # update graphs manually
          echo "already_doing_it" >"${LOG_DIR:?}"/node_data/graph.lock 2>&1
          printf '%b' "[${G1:?}Ok${N0:?}] Updating graphs..\n"
          echo
          bash /usr/local/bin/include/graphs
          echo
          read -r -p "[Ok] Press Enter to continue" </dev/tty
          clear
          rm "${LOG_DIR:?}"/node_data/graph.lock &>/dev/null
        fi
      fi

      ;;

    "2")

      display_result() {
        dialog --title "$1" \
          --no-collapse \
          --msgbox "$RESULT" 0 0
      }

      RESULT=$(echo "$(dir -lh stats/ 2>&1)")
      display_result "rrdtool Database info"

      ;;

    "3")

      printf '%b' "[${R1:?}WARNING${N0:?}] Databases has room for 3 years of data!\n"
      echo "[!!] Space is already set ($(du -sh stats/ 2>&1 | awk '{ print $1 }' 2>&1) -> $(du -k stats/ 2>&1 | awk '{ print $1 }' 2>&1)), are you sure?"
      read -r -p "[YN] Remove graph databases? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
        rm -r /home/"$(whoami)"/stats/* &>/dev/null
        echo
        read -r -p "[Ok] rrdtool graphs removed! Press Enter to continue" </dev/tty
        echo
      fi

      ;;

    esac

    ;;

  "10")

    HEIGHT=11
    WIDTH=51
    CHOICE_HEIGHT=4
    BACKTITLE="Reset configurations"
    TITLE="Reset a specific config"
    MENU="Choose one option:"

    OPTIONS=(1 "${WALLET_CONFIG:?}   Reset wallet config"
      2 "pinode.conf      Reset pi-node config"
      3 "config.txt       Reset boot/config.txt"
      4 "torrc            Reset Tor config")

    CHOICE=$(dialog --clear \
      --backtitle "$BACKTITLE" \
      --title "$TITLE" \
      --menu "$MENU" \
      $HEIGHT $WIDTH $CHOICE_HEIGHT \
      "${OPTIONS[@]}" \
      2>&1 >/dev/tty)

    clear
    case $CHOICE in

    "1")

      read -r -p "[YN] Hard reset of ${WALLET_CONFIG:?}? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

        mkdir "${WALLET_DIR:?}" &>/dev/null

        # create random rpcuser & rpcpassword
        RANDOM_RPCL=$(tr -dc 'a-z' </dev/urandom 2>&1 | head -c 4 2>&1 | rev 2>&1)
        RANDOM_RPCN=$(echo "$RANDOM_RPCL" 2>&1 | rev 2>&1)

        # get proxy (tor) hostname with root
        EXTERNALIP=$(sudo cat /var/lib/tor/"${WALLET_DAEMON:?}"-service/hostname 2>/dev/null)

        if [[ -z "$EXTERNALIP" ]] &>/dev/null; then
          # non responsive
          EXTERNALIP="#externalip=PLEASE_EDIT"
        else
          EXTERNALIP="externalip=${EXTERNALIP:?}"
        fi

        echo "## ${WALLET_CONFIG:?} configuration file.
# Network-related settings:

# Run on the test network instead of the real ${WALLET_NAME:?} network.
#testnet=1

# RPC credentials
rpcuser=${RANDOM_RPCL:?}${RANDOM_RPCN:?}
rpcpassword=${RANDOM_RPCN:?}${RANDOM_RPCL:?}
rpcallowip=${RPC_IP:?}
rpcbind=${RPC_IP:?}

# Connect via a SOCKS5 proxy (default: 127.0.0.1:9050)
proxy=${PROXY:?}

# Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: -proxy)
onion=${PROXY:?}

# Tor control port to use if onion listening enabled (default: 127.0.0.1:9051)
torcontrol=${TOR_CONTROL:?}

# Tor onion externalip
${EXTERNALIP:?}

# Listening mode, enabled by default except when 'connect' is being used
listen=1
discover=1

# Maximum number of inbound+outbound connections. (default: 125)
maxconnections=${MAX_P2P:?}

# can be commented out if you use the service script
daemon=1" >"${WALLET_DIR:?}"/"${WALLET_CONFIG:?}".tmp 2>&1
        mv "${WALLET_DIR:?}"/"${WALLET_CONFIG:?}".tmp "${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" 2>&1
        echo "[Ok] Installed new wallet configuration! -> ${WALLET_DIR:?}/${WALLET_CONFIG:?}"
        echo
        read -r -p "[Ok] Press Enter to continue" </dev/tty
        echo
      fi

      ;;

    "2")

      read -r -p "[YN] Hard reset of pinode.conf? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

        echo "Reset pinode.conf!"
        cp /home/"$(whoami)"/pi-node/pinode.conf /home/"$(whoami)"/
        echo
        read -r -p "[Ok] Press Enter to continue" </dev/tty
        echo
      fi

      ;;

    "3")

      read -r -p "[YN] Hard reset of config.txt? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

        echo "Creating backup! (/boot/config.txt)"
        cp /boot/config.txt /home/"$(whoami)"/
        echo
        read -r -p "[Ok] Press Enter to continue" </dev/tty
        echo
      fi

      ;;

    "4")

      read -r -p "[YN] Hard reset of tor? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

        # get wallet port, do this once
        if [[ ! -f "${WALLET_DIR:?}"/wallet_port ]] &>/dev/null; then
          printf '%b' "[??] Enter wallet Port ${G1:?}> ${N0:?}"
          read -r PORT
          echo "${PORT:?}" >"${WALLET_DIR:?}"/wallet_port 2>&1
          if [[ -z "$PORT" ]] &>/dev/null; then
            # empty, exit
            printf '%b' "[${R1:?}!!${N0:?}] Empty, try again\n"
            exit
          fi
        fi

        sudo rm -R /var/lib/tor/"${WALLET_DAEMON:?}"-service/ &>/dev/null
        sudo rm -R "${WALLET_DIR:?}"/onion* &>/dev/null

        # tor group, user configuration
        TORGROUP=$(stat -c '%G' /run/tor/control.authcookie 2>/dev/null)
        sudo usermod -a -G "${TORGROUP:?}" "$(whoami)" 2>/dev/null

        # if data missing, add values
        if ! grep "${WALLET_NAME:?}" /etc/tor/torrc &>/dev/null; then

          read -r -p "[YN] Public .onion web server? y/n " -n 1 -r
          echo
          if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
            HIDDEN_SERVICE="HiddenServicePort 80 127.0.0.1:80"
          else
            HIDDEN_SERVICE="#HiddenServicePort 80 127.0.0.1:80"
          fi

          echo "RunAsDaemon 1

ControlPort 9051
CookieAuthentication 1
CookieAuthFileGroupReadable 1

HiddenServiceDir /var/lib/tor/${WALLET_NAME:?}-service/
HiddenServicePort ${PORT:?} 127.0.0.1:${PORT:?}
${HIDDEN_SERVICE:?}
" >"${LOG_DIR:?}"/torrc 2>&1

          cat "${LOG_DIR:?}"/torrc 2>/dev/null | sudo tee -a /etc/tor/torrc 2>&1
          # remove old files
          rm "${LOG_DIR:?}"/torrc &>/dev/null
        fi

        # restart tor after configuration
        sudo service tor restart 2>&1
        printf '%b' "[${Y1:?}!!${N0:?}] Please reset wallet configuration!\n"
        echo
        read -r -p "[Ok] Hard reset of tor done! Press Enter to continue" </dev/tty
        echo
      fi

      ;;

    esac

    ;;

    # backup files

  "11")

    read -r -p "[YN] Backup files (backups/keys)? y/n " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

      # backup with wallet, backupwallet
      printf '%b' "[${Y1:?}!!${N0:?}] backupwallet, please wait!\n"
      "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" backupwallet "${WALLET_DIR:?}"/backups
      printf '%b' "[${G1:?}Ok${N0:?}] $(ls -lSh "${WALLET_DIR:?}"/backups/wallet.dat 2>/dev/null)\n"

      # zip backups directory
      printf '%b' "[${Y1:?}!!${N0:?}] Zipping backup, please wait!\n"
      if [[ -f /home/"$(whoami)"/backup.zip ]] &>/dev/null; then
        zip -r /home/"$(whoami)"/backup.zip "${WALLET_DIR:?}"/backups/*
      else
        zip -r /home/"$(whoami)"/backup.zip "${WALLET_DIR:?}"/backups/*
      fi
      printf '%b' "[${G1:?}Ok${N0:?}] $(ls -lSh /home/"$(whoami)"/backup.zip 2>/dev/null)\n"
      echo
      read -r -p "[Ok] Backups is done! Press Enter to continue" </dev/tty
      echo
    fi

    ;;

  esac

  ;;

  # swap options

"7")

  # get total physical system memory, do this once
  if [[ ! -f "${WALLET_DIR:?}"/swapinfo ]] &>/dev/null; then
    echo "$(free --mega 2>&1 | grep "Mem" 2>&1 | awk '{ print $2 }' 2>&1)+$(free --mega 2>&1 | grep "Swap" 2>&1 | awk '{ print $2 }' 2>&1)" 2>&1 | bc >"${WALLET_DIR:?}"/swapinfo 2>&1
  fi

  if [[ ! -f /swapfile ]] &>/dev/null; then

    # if physical memory greater than n megabytes, don't install
    if [[ "$(cat "${WALLET_DIR:?}"/swapinfo 2>/dev/null)" -gt "1200" ]] &>/dev/null; then
      # system has enough memory
      printf '%b' "[${G1:?}Ok${N0:?}] System has enough sufficient memory ${G1:?}$(cat "${WALLET_DIR:?}"/swapinfo 2>/dev/null)MB${N0:?}\n"
      # output memory, swap info
      echo
      sudo free -h
      echo
      sudo swapon --show
      echo
      read -r -p "[Ok] No need for swap! Press Enter to continue" </dev/tty
      echo
    else
      read -r -p "[YN] Automatically setup new swap? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

        # fallocate a file that will be used for swap
        sudo fallocate -l 1G /swapfile

        read -r -p "[YN] chmod, mkswap, swapon? y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
          # root user should be able to write and read the swap file
          sudo chmod 600 /swapfile
          # mkswap utility to set up the file as Linux swap area
          sudo mkswap /swapfile
          # enable the swap
          sudo swapon /swapfile
          echo
          read -r -p "[Ok] Press Enter to continue" </dev/tty
          echo
        fi

        if [[ ! "$(grep "swap swap" /etc/fstab 2>&1)" ]] &>/dev/null; then
          # no swap installed, continue
          echo "[Ok] No Swap installed"
          # make change permanent
          echo "/swapfile swap swap defaults 0 0" >"${LOG_DIR:?}"/fstab.tmp
          cat "${LOG_DIR:?}"/fstab.tmp 2>/dev/null | sudo tee -a /etc/fstab 2>&1
          # remove old file
          rm "${LOG_DIR:?}"/fstab.tmp &>/dev/null
        else
          echo "[Ok] Swap already installed! -> /etc/fstab"
        fi
      fi
    fi
  else
    echo "[Ok] Swap already installed!"
    sleep 1
  fi

  # swap menu, after the fact

  HEIGHT=11
  WIDTH=45
  CHOICE_HEIGHT=4
  BACKTITLE="Swap options"
  TITLE="Setup Swap space"
  MENU="Choose one option:"

  OPTIONS=(1 "Create           Create swapfile"
    2 "Delete           Delete swapfile"
    3 "Status           Swap information"
    4 "DTR              Data to RAM")

  CHOICE=$(dialog --clear \
    --backtitle "$BACKTITLE" \
    --title "$TITLE" \
    --menu "$MENU" \
    $HEIGHT $WIDTH $CHOICE_HEIGHT \
    "${OPTIONS[@]}" \
    2>&1 >/dev/tty)

  clear
  case $CHOICE in

  # create swap

  "1")

    echo "Creating Swap manually!"
    printf '%b' "Enter Gigabytes ${G1:?}>${N0:?} "
    read -r SWAPG
    if [[ -z "$SWAPG" ]] &>/dev/null; then
      echo "empty!"
      exit
    fi

    # fallocate a file that will be used for swap
    sudo fallocate -l "${SWAPG:?}"G /swapfile
    # root user should be able to write and read the swap file
    sudo chmod 600 /swapfile
    # mkswap utility to set up the file as Linux swap area
    sudo mkswap /swapfile
    # enable the swap
    sudo swapon /swapfile
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo

    if [[ ! "$(grep "swap swap" /etc/fstab 2>&1)" ]] &>/dev/null; then
      # no swap installed, continue
      echo "[Ok] No Swap installed"
      #To make the change permanent open the /etc/fstab file and append the following line:
      echo "/swapfile swap swap defaults 0 0" >"${LOG_DIR:?}"/fstab.tmp 2>&1
      cat "${LOG_DIR:?}"/fstab.tmp 2>/dev/null | sudo tee -a /etc/fstab 2>&1
      # remove old file
      rm "${LOG_DIR:?}"/fstab.tmp &>/dev/null
    fi

    # output memory, swap info
    echo
    sudo free -h
    echo
    sudo swapon --show
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo

    ;;

    # delete swap

  "2")

    read -r -p "[YN] Remove Swap? y/n " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
      sudo swapoff /swapfile 2>&1
      sudo rm /swapfile &>/dev/null
      echo "Remove line -> '/swapfile swap swap defaults 0 0' in /etc/fstab"
      read -r -p "[Ok] Press Enter to continue" </dev/tty
      sudo nano /etc/fstab
      read -r -p "[YN] Reboot system? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
        sudo reboot
      fi
    fi

    ;;

    # swap status (megabytes)

  "3")

    display_result() {
      dialog --title "Memory Status - System memory $(free --total --mega 2>&1 | grep "Mem:" 2>&1 | awk '{ print $2 }' 2>&1)Mb" \
        --no-collapse \
        --msgbox "$RESULT" 0 0
    }

    # output total memory, swap info
    RESULT=$(
      free --total --mega
      echo
      ls -lSh /var/swap 2>/dev/null
      ls -lSh /swapfile 2>/dev/null
      swapon -V
    )
    display_result "System memory information"
    clear

    ;;

    # setup data to ram

  "4")

    function check_crontab() {
      # look for crontab setup
      if ! sudo crontab -l 2>&1 | grep "@reboot" &>/dev/null; then
        CRON_JOB="@reboot sudo mkdir /var/log/apache2"
        (# add cron job for apache2 @reboot (root)
          sudo crontab -l 2>/dev/null
          echo "${CRON_JOB:?}"
        ) | sudo crontab -
        printf '%b' "[${Y1:?}Ok${N0:?}] (sudo) Crontab installing!\n"
      else
        printf '%b' "[${G1:?}Ok${N0:?}] (sudo) Crontab installed!\n"
      fi
    }

    # look for data to ram setup
    if grep "tmpfs /tmp tmpfs defaults,noatime,nosuid,size=" /etc/fstab &>/dev/null; then
      check_crontab
      printf '%b' "[${G1:?}Ok${N0:?}] (sudo) Data to RAM installed!\n"
    else

      read -r -p "[YN] Setup data to RAM? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then

        check_crontab
        printf '%b' "Enter tmp size ${GR:?}Enter for default${N0:?}
${G1:?}>${N0:?} "
        read -r RAM_SIZE
        if [[ -z "$RAM_SIZE" ]] &>/dev/null; then
          printf '%b' "[${Y1:?}!!${N0:?}] Empty! Using default 128 (megabytes)\n"
          RAM_SIZE="128" # default set
          sleep 2
        else # user set
          printf '%b' "[${G1:?}!!${N0:?}] Using ${RAM_SIZE:?} (megabytes)\n"
        fi
        printf '%b' "Enter spool size ${GR:?}Enter for default${N0:?}
${G1:?}>${N0:?} "
        read -r RAM_SIZE_SPOOL
        if [[ -z "$RAM_SIZE_SPOOL" ]] &>/dev/null; then
          printf '%b' "[${Y1:?}!!${N0:?}] Empty! Using default 64 (megabytes)\n"
          RAM_SIZE_SPOOL="64" # default set
          sleep 2
        else # user set
          printf '%b' "[${G1:?}!!${N0:?}] Using ${RAM_SIZE_SPOOL:?} (megabytes)\n"
        fi
        # setup data to ram in fstab
        echo "tmpfs /tmp tmpfs defaults,noatime,nosuid,size=${RAM_SIZE:?}m 0 0
tmpfs /var/tmp tmpfs defaults,noatime,nosuid,size=${RAM_SIZE:?}m 0 0
tmpfs /var/log tmpfs defaults,noatime,nosuid,mode=0755,size=${RAM_SIZE:?}m 0 0
tmpfs /var/spool/mqueue tmpfs defaults,noatime,nosuid,mode=0700,gid=12,size=${RAM_SIZE_SPOOL:?}m 0 0" >"${LOG_DIR:?}"/fstab.tmp
        cat "${LOG_DIR:?}"/fstab.tmp 2>/dev/null | sudo tee -a /etc/fstab 2>&1
        # remove old file
        rm "${LOG_DIR:?}"/fstab.tmp &>/dev/null
        read -r -p "[YN] Reboot system? y/n " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
          printf '%b' "[${R1:?}!!${N0:?}] "
          "${WALLET_DIR:?}"/"${WALLET_CLIENT:?}" -datadir="${DATA_DIR:?}" -debuglogfile="${WALLET_LOG_DIR:?}"/debug.log -conf="${WALLET_DIR:?}"/"${WALLET_CONFIG:?}" stop && sleep 5
          # wait on node (daemon) to stop
          until ! pidof "${WALLET_DAEMON:?}" 2>&1 | wc -w 2>&1 | egrep "1" &>/dev/null; do
            clear
            printf '%b' "[${R1:?}!!${N0:?}] waiting on wallet (${G1:?}$(pidof "${WALLET_DAEMON:?}" 2>&1)${N0:?}) daemon to shutdown..\n"
            printf '%b' "${GR:?}CTRL+C to exit${N0:?}\n"
            sleep 10
            kill -9 "$(pidof "${WALLET_DAEMON:?}" 2>&1)" &>/dev/null
          done
          sudo reboot
        fi
      fi
    fi
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo

    ;;

  esac

  ;;

  # proxy (tor) menu

"9")

  HEIGHT=10
  WIDTH=47
  CHOICE_HEIGHT=3
  BACKTITLE="Tor menu"
  TITLE="Proxy options (tor)"
  MENU="Choose one option:"

  OPTIONS=(1 "Stop             Stop tor service"
    2 "Restart          Restart tor service"
    3 "Monitor          Tor monitor")

  CHOICE=$(dialog --clear \
    --backtitle "$BACKTITLE" \
    --title "$TITLE" \
    --menu "$MENU" \
    $HEIGHT $WIDTH $CHOICE_HEIGHT \
    "${OPTIONS[@]}" \
    2>&1 >/dev/tty)

  clear
  case $CHOICE in

  "1")

    printf '%b' "[${Y1:?}!!${N0:?}] Stopping!\n"
    printf '%b' "[${Y1:?}!!${N0:?}] $(sudo service tor stop)!\n"
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo

    ;;

  "2")

    printf '%b' "[${Y1:?}!!${N0:?}] Restarting!\n"
    printf '%b' "[${Y1:?}!!${N0:?}] $(sudo service tor restart)!\n"
    echo
    read -r -p "[Ok] Press Enter to continue" </dev/tty
    echo

    ;;

    # nyx - https://nyx.torproject.org

  "3")

    if ! [ -x "$(command -v nyx)" ] &>/dev/null; then
      read -r -p "[YN] Install Nyx (command-line monitor for Tor)? y/n " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]] &>/dev/null; then
        sudo apt-get install nyx -y
        echo
        read -r -p "[Ok] nyx installed! Press Enter to continue" </dev/tty
        echo
        # run nyx
        nyx
      fi
    else
      # run nyx
      nyx
    fi

    ;;

  esac

  ;;

"10")

  exit # exit menu

  ;;

esac

exec /bin/bash "$0" "$@"

# END
